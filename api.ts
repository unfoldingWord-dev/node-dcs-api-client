/**
 * DCS (Gitea) API.
 * This documentation describes the DCS (Gitea) API.
 *
 * OpenAPI spec version: 1.16.2+dcs
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

let defaultBasePath = 'http://localhost/api/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* APIError is an api error with a message
*/
export class APIError {
    'message'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return APIError.attributeTypeMap;
    }
}

export class AccessToken {
    'id'?: number;
    'name'?: string;
    'sha1'?: string;
    'tokenLastEight'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "sha1",
            "baseName": "sha1",
            "type": "string"
        },
        {
            "name": "tokenLastEight",
            "baseName": "token_last_eight",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AccessToken.attributeTypeMap;
    }
}

/**
* AddCollaboratorOption options when adding a user as a collaborator of a repository
*/
export class AddCollaboratorOption {
    'permission'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "permission",
            "baseName": "permission",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddCollaboratorOption.attributeTypeMap;
    }
}

/**
* AddTimeOption options for adding time to an issue
*/
export class AddTimeOption {
    'created'?: Date;
    /**
    * time in seconds
    */
    'time': number;
    /**
    * User who spent the time (optional)
    */
    'userName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        },
        {
            "name": "userName",
            "baseName": "user_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddTimeOption.attributeTypeMap;
    }
}

/**
* AnnotatedTag represents an annotated tag
*/
export class AnnotatedTag {
    'message'?: string;
    'object'?: AnnotatedTagObject;
    'sha'?: string;
    'tag'?: string;
    'tagger'?: CommitUser;
    'url'?: string;
    'verification'?: PayloadCommitVerification;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "AnnotatedTagObject"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "tagger",
            "baseName": "tagger",
            "type": "CommitUser"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "verification",
            "baseName": "verification",
            "type": "PayloadCommitVerification"
        }    ];

    static getAttributeTypeMap() {
        return AnnotatedTag.attributeTypeMap;
    }
}

/**
* AnnotatedTagObject contains meta information of the tag object
*/
export class AnnotatedTagObject {
    'sha'?: string;
    'type'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AnnotatedTagObject.attributeTypeMap;
    }
}

/**
* Attachment a generic attachment
*/
export class Attachment {
    'browserDownloadUrl'?: string;
    'createdAt'?: Date;
    'downloadCount'?: number;
    'id'?: number;
    'name'?: string;
    'size'?: number;
    'uuid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "browserDownloadUrl",
            "baseName": "browser_download_url",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "downloadCount",
            "baseName": "download_count",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "uuid",
            "baseName": "uuid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Attachment.attributeTypeMap;
    }
}

/**
* Branch represents a repository branch
*/
export class Branch {
    'commit'?: PayloadCommit;
    'effectiveBranchProtectionName'?: string;
    'enableStatusCheck'?: boolean;
    'name'?: string;
    '_protected'?: boolean;
    'requiredApprovals'?: number;
    'statusCheckContexts'?: Array<string>;
    'userCanMerge'?: boolean;
    'userCanPush'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commit",
            "baseName": "commit",
            "type": "PayloadCommit"
        },
        {
            "name": "effectiveBranchProtectionName",
            "baseName": "effective_branch_protection_name",
            "type": "string"
        },
        {
            "name": "enableStatusCheck",
            "baseName": "enable_status_check",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "_protected",
            "baseName": "protected",
            "type": "boolean"
        },
        {
            "name": "requiredApprovals",
            "baseName": "required_approvals",
            "type": "number"
        },
        {
            "name": "statusCheckContexts",
            "baseName": "status_check_contexts",
            "type": "Array<string>"
        },
        {
            "name": "userCanMerge",
            "baseName": "user_can_merge",
            "type": "boolean"
        },
        {
            "name": "userCanPush",
            "baseName": "user_can_push",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Branch.attributeTypeMap;
    }
}

/**
* BranchProtection represents a branch protection for a repository
*/
export class BranchProtection {
    'approvalsWhitelistTeams'?: Array<string>;
    'approvalsWhitelistUsername'?: Array<string>;
    'blockOnOfficialReviewRequests'?: boolean;
    'blockOnOutdatedBranch'?: boolean;
    'blockOnRejectedReviews'?: boolean;
    'branchName'?: string;
    'createdAt'?: Date;
    'dismissStaleApprovals'?: boolean;
    'enableApprovalsWhitelist'?: boolean;
    'enableMergeWhitelist'?: boolean;
    'enablePush'?: boolean;
    'enablePushWhitelist'?: boolean;
    'enableStatusCheck'?: boolean;
    'mergeWhitelistTeams'?: Array<string>;
    'mergeWhitelistUsernames'?: Array<string>;
    'protectedFilePatterns'?: string;
    'pushWhitelistDeployKeys'?: boolean;
    'pushWhitelistTeams'?: Array<string>;
    'pushWhitelistUsernames'?: Array<string>;
    'requireSignedCommits'?: boolean;
    'requiredApprovals'?: number;
    'statusCheckContexts'?: Array<string>;
    'unprotectedFilePatterns'?: string;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "approvalsWhitelistTeams",
            "baseName": "approvals_whitelist_teams",
            "type": "Array<string>"
        },
        {
            "name": "approvalsWhitelistUsername",
            "baseName": "approvals_whitelist_username",
            "type": "Array<string>"
        },
        {
            "name": "blockOnOfficialReviewRequests",
            "baseName": "block_on_official_review_requests",
            "type": "boolean"
        },
        {
            "name": "blockOnOutdatedBranch",
            "baseName": "block_on_outdated_branch",
            "type": "boolean"
        },
        {
            "name": "blockOnRejectedReviews",
            "baseName": "block_on_rejected_reviews",
            "type": "boolean"
        },
        {
            "name": "branchName",
            "baseName": "branch_name",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "dismissStaleApprovals",
            "baseName": "dismiss_stale_approvals",
            "type": "boolean"
        },
        {
            "name": "enableApprovalsWhitelist",
            "baseName": "enable_approvals_whitelist",
            "type": "boolean"
        },
        {
            "name": "enableMergeWhitelist",
            "baseName": "enable_merge_whitelist",
            "type": "boolean"
        },
        {
            "name": "enablePush",
            "baseName": "enable_push",
            "type": "boolean"
        },
        {
            "name": "enablePushWhitelist",
            "baseName": "enable_push_whitelist",
            "type": "boolean"
        },
        {
            "name": "enableStatusCheck",
            "baseName": "enable_status_check",
            "type": "boolean"
        },
        {
            "name": "mergeWhitelistTeams",
            "baseName": "merge_whitelist_teams",
            "type": "Array<string>"
        },
        {
            "name": "mergeWhitelistUsernames",
            "baseName": "merge_whitelist_usernames",
            "type": "Array<string>"
        },
        {
            "name": "protectedFilePatterns",
            "baseName": "protected_file_patterns",
            "type": "string"
        },
        {
            "name": "pushWhitelistDeployKeys",
            "baseName": "push_whitelist_deploy_keys",
            "type": "boolean"
        },
        {
            "name": "pushWhitelistTeams",
            "baseName": "push_whitelist_teams",
            "type": "Array<string>"
        },
        {
            "name": "pushWhitelistUsernames",
            "baseName": "push_whitelist_usernames",
            "type": "Array<string>"
        },
        {
            "name": "requireSignedCommits",
            "baseName": "require_signed_commits",
            "type": "boolean"
        },
        {
            "name": "requiredApprovals",
            "baseName": "required_approvals",
            "type": "number"
        },
        {
            "name": "statusCheckContexts",
            "baseName": "status_check_contexts",
            "type": "Array<string>"
        },
        {
            "name": "unprotectedFilePatterns",
            "baseName": "unprotected_file_patterns",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return BranchProtection.attributeTypeMap;
    }
}

/**
* CatalogStage a repo's catalog stage metadata
*/
export class CatalogStage {
    'branchOrTagName'?: string;
    'contentsUrl'?: string;
    'gitTreesUrl'?: string;
    'releaseUrl'?: string;
    'released'?: Date;
    'tarballUrl'?: string;
    'zipballUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "branchOrTagName",
            "baseName": "branch_or_tag_name",
            "type": "string"
        },
        {
            "name": "contentsUrl",
            "baseName": "contents_url",
            "type": "string"
        },
        {
            "name": "gitTreesUrl",
            "baseName": "git_trees_url",
            "type": "string"
        },
        {
            "name": "releaseUrl",
            "baseName": "release_url",
            "type": "string"
        },
        {
            "name": "released",
            "baseName": "released",
            "type": "Date"
        },
        {
            "name": "tarballUrl",
            "baseName": "tarball_url",
            "type": "string"
        },
        {
            "name": "zipballUrl",
            "baseName": "zipball_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CatalogStage.attributeTypeMap;
    }
}

/**
* CatalogStages a repo's catalog stages
*/
export class CatalogStages {
    'draft'?: CatalogStage;
    'latest'?: CatalogStage;
    'preprod'?: CatalogStage;
    'prod'?: CatalogStage;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "draft",
            "baseName": "draft",
            "type": "CatalogStage"
        },
        {
            "name": "latest",
            "baseName": "latest",
            "type": "CatalogStage"
        },
        {
            "name": "preprod",
            "baseName": "preprod",
            "type": "CatalogStage"
        },
        {
            "name": "prod",
            "baseName": "prod",
            "type": "CatalogStage"
        }    ];

    static getAttributeTypeMap() {
        return CatalogStages.attributeTypeMap;
    }
}

/**
* CombinedStatus holds the combined state of several statuses for a single commit
*/
export class CombinedStatus {
    'commitUrl'?: string;
    'repository'?: Repository;
    'sha'?: string;
    'state'?: CommitStatusState;
    'statuses'?: Array<CommitStatus>;
    'totalCount'?: number;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commitUrl",
            "baseName": "commit_url",
            "type": "string"
        },
        {
            "name": "repository",
            "baseName": "repository",
            "type": "Repository"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "CommitStatusState"
        },
        {
            "name": "statuses",
            "baseName": "statuses",
            "type": "Array<CommitStatus>"
        },
        {
            "name": "totalCount",
            "baseName": "total_count",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CombinedStatus.attributeTypeMap;
    }
}

/**
* Comment represents a comment on a commit or issue
*/
export class Comment {
    'body'?: string;
    'createdAt'?: Date;
    'htmlUrl'?: string;
    'id'?: number;
    'issueUrl'?: string;
    'originalAuthor'?: string;
    'originalAuthorId'?: number;
    'pullRequestUrl'?: string;
    'updatedAt'?: Date;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "issueUrl",
            "baseName": "issue_url",
            "type": "string"
        },
        {
            "name": "originalAuthor",
            "baseName": "original_author",
            "type": "string"
        },
        {
            "name": "originalAuthorId",
            "baseName": "original_author_id",
            "type": "number"
        },
        {
            "name": "pullRequestUrl",
            "baseName": "pull_request_url",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return Comment.attributeTypeMap;
    }
}

export class Commit {
    'author'?: User;
    'commit'?: RepoCommit;
    'committer'?: User;
    'created'?: Date;
    'files'?: Array<CommitAffectedFiles>;
    'htmlUrl'?: string;
    'parents'?: Array<CommitMeta>;
    'sha'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "User"
        },
        {
            "name": "commit",
            "baseName": "commit",
            "type": "RepoCommit"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "User"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "files",
            "baseName": "files",
            "type": "Array<CommitAffectedFiles>"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "Array<CommitMeta>"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Commit.attributeTypeMap;
    }
}

/**
* CommitAffectedFiles store information about files affected by the commit
*/
export class CommitAffectedFiles {
    'filename'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CommitAffectedFiles.attributeTypeMap;
    }
}

/**
* CommitDateOptions store dates for GIT_AUTHOR_DATE and GIT_COMMITTER_DATE
*/
export class CommitDateOptions {
    'author'?: Date;
    'committer'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "Date"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return CommitDateOptions.attributeTypeMap;
    }
}

export class CommitMeta {
    'created'?: Date;
    'sha'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CommitMeta.attributeTypeMap;
    }
}

/**
* CommitStatus holds a single status of a single Commit
*/
export class CommitStatus {
    'context'?: string;
    'createdAt'?: Date;
    'creator'?: User;
    'description'?: string;
    'id'?: number;
    'status'?: CommitStatusState;
    'targetUrl'?: string;
    'updatedAt'?: Date;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "creator",
            "baseName": "creator",
            "type": "User"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "CommitStatusState"
        },
        {
            "name": "targetUrl",
            "baseName": "target_url",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CommitStatus.attributeTypeMap;
    }
}

/**
* CommitStatusState holds the state of a CommitStatus It can be \"pending\", \"success\", \"error\", \"failure\", and \"warning\"
*/
export class CommitStatusState {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return CommitStatusState.attributeTypeMap;
    }
}

export class CommitUser {
    'date'?: string;
    'email'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CommitUser.attributeTypeMap;
    }
}

/**
* ContentsResponse contains information about a repo's entry's (dir, file, symlink, submodule) metadata and content
*/
export class ContentsResponse {
    'links'?: FileLinksResponse;
    /**
    * `content` is populated when `type` is `file`, otherwise null
    */
    'content'?: string;
    'downloadUrl'?: string;
    /**
    * `encoding` is populated when `type` is `file`, otherwise null
    */
    'encoding'?: string;
    'gitUrl'?: string;
    'htmlUrl'?: string;
    'name'?: string;
    'path'?: string;
    'sha'?: string;
    'size'?: number;
    /**
    * `submodule_git_url` is populated when `type` is `submodule`, otherwise null
    */
    'submoduleGitUrl'?: string;
    /**
    * `target` is populated when `type` is `symlink`, otherwise null
    */
    'target'?: string;
    /**
    * `type` will be `file`, `dir`, `symlink`, or `submodule`
    */
    'type'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "FileLinksResponse"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "downloadUrl",
            "baseName": "download_url",
            "type": "string"
        },
        {
            "name": "encoding",
            "baseName": "encoding",
            "type": "string"
        },
        {
            "name": "gitUrl",
            "baseName": "git_url",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "submoduleGitUrl",
            "baseName": "submodule_git_url",
            "type": "string"
        },
        {
            "name": "target",
            "baseName": "target",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ContentsResponse.attributeTypeMap;
    }
}

/**
* CreateAccessTokenOption options when create access token
*/
export class CreateAccessTokenOption {
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAccessTokenOption.attributeTypeMap;
    }
}

/**
* CreateBranchProtectionOption options for creating a branch protection
*/
export class CreateBranchProtectionOption {
    'approvalsWhitelistTeams'?: Array<string>;
    'approvalsWhitelistUsername'?: Array<string>;
    'blockOnOfficialReviewRequests'?: boolean;
    'blockOnOutdatedBranch'?: boolean;
    'blockOnRejectedReviews'?: boolean;
    'branchName'?: string;
    'dismissStaleApprovals'?: boolean;
    'enableApprovalsWhitelist'?: boolean;
    'enableMergeWhitelist'?: boolean;
    'enablePush'?: boolean;
    'enablePushWhitelist'?: boolean;
    'enableStatusCheck'?: boolean;
    'mergeWhitelistTeams'?: Array<string>;
    'mergeWhitelistUsernames'?: Array<string>;
    'protectedFilePatterns'?: string;
    'pushWhitelistDeployKeys'?: boolean;
    'pushWhitelistTeams'?: Array<string>;
    'pushWhitelistUsernames'?: Array<string>;
    'requireSignedCommits'?: boolean;
    'requiredApprovals'?: number;
    'statusCheckContexts'?: Array<string>;
    'unprotectedFilePatterns'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "approvalsWhitelistTeams",
            "baseName": "approvals_whitelist_teams",
            "type": "Array<string>"
        },
        {
            "name": "approvalsWhitelistUsername",
            "baseName": "approvals_whitelist_username",
            "type": "Array<string>"
        },
        {
            "name": "blockOnOfficialReviewRequests",
            "baseName": "block_on_official_review_requests",
            "type": "boolean"
        },
        {
            "name": "blockOnOutdatedBranch",
            "baseName": "block_on_outdated_branch",
            "type": "boolean"
        },
        {
            "name": "blockOnRejectedReviews",
            "baseName": "block_on_rejected_reviews",
            "type": "boolean"
        },
        {
            "name": "branchName",
            "baseName": "branch_name",
            "type": "string"
        },
        {
            "name": "dismissStaleApprovals",
            "baseName": "dismiss_stale_approvals",
            "type": "boolean"
        },
        {
            "name": "enableApprovalsWhitelist",
            "baseName": "enable_approvals_whitelist",
            "type": "boolean"
        },
        {
            "name": "enableMergeWhitelist",
            "baseName": "enable_merge_whitelist",
            "type": "boolean"
        },
        {
            "name": "enablePush",
            "baseName": "enable_push",
            "type": "boolean"
        },
        {
            "name": "enablePushWhitelist",
            "baseName": "enable_push_whitelist",
            "type": "boolean"
        },
        {
            "name": "enableStatusCheck",
            "baseName": "enable_status_check",
            "type": "boolean"
        },
        {
            "name": "mergeWhitelistTeams",
            "baseName": "merge_whitelist_teams",
            "type": "Array<string>"
        },
        {
            "name": "mergeWhitelistUsernames",
            "baseName": "merge_whitelist_usernames",
            "type": "Array<string>"
        },
        {
            "name": "protectedFilePatterns",
            "baseName": "protected_file_patterns",
            "type": "string"
        },
        {
            "name": "pushWhitelistDeployKeys",
            "baseName": "push_whitelist_deploy_keys",
            "type": "boolean"
        },
        {
            "name": "pushWhitelistTeams",
            "baseName": "push_whitelist_teams",
            "type": "Array<string>"
        },
        {
            "name": "pushWhitelistUsernames",
            "baseName": "push_whitelist_usernames",
            "type": "Array<string>"
        },
        {
            "name": "requireSignedCommits",
            "baseName": "require_signed_commits",
            "type": "boolean"
        },
        {
            "name": "requiredApprovals",
            "baseName": "required_approvals",
            "type": "number"
        },
        {
            "name": "statusCheckContexts",
            "baseName": "status_check_contexts",
            "type": "Array<string>"
        },
        {
            "name": "unprotectedFilePatterns",
            "baseName": "unprotected_file_patterns",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateBranchProtectionOption.attributeTypeMap;
    }
}

/**
* CreateBranchRepoOption options when creating a branch in a repository
*/
export class CreateBranchRepoOption {
    /**
    * Name of the branch to create
    */
    'newBranchName': string;
    /**
    * Name of the old branch to create from
    */
    'oldBranchName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "newBranchName",
            "baseName": "new_branch_name",
            "type": "string"
        },
        {
            "name": "oldBranchName",
            "baseName": "old_branch_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateBranchRepoOption.attributeTypeMap;
    }
}

/**
* CreateEmailOption options when creating email addresses
*/
export class CreateEmailOption {
    /**
    * email addresses to add
    */
    'emails'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emails",
            "baseName": "emails",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CreateEmailOption.attributeTypeMap;
    }
}

/**
* CreateFileOptions options for creating files Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
*/
export class CreateFileOptions {
    'author'?: Identity;
    /**
    * branch (optional) to base this file from. if not given, the default branch is used
    */
    'branch'?: string;
    'committer'?: Identity;
    /**
    * content must be base64 encoded
    */
    'content': string;
    'dates'?: CommitDateOptions;
    /**
    * message (optional) for the commit of this file. if not supplied, a default message will be used
    */
    'message'?: string;
    /**
    * new_branch (optional) will make a new branch from `branch` before creating the file
    */
    'newBranch'?: string;
    /**
    * Add a Signed-off-by trailer by the committer at the end of the commit log message.
    */
    'signoff'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "Identity"
        },
        {
            "name": "branch",
            "baseName": "branch",
            "type": "string"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "Identity"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "dates",
            "baseName": "dates",
            "type": "CommitDateOptions"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "newBranch",
            "baseName": "new_branch",
            "type": "string"
        },
        {
            "name": "signoff",
            "baseName": "signoff",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CreateFileOptions.attributeTypeMap;
    }
}

/**
* CreateForkOption options for creating a fork
*/
export class CreateForkOption {
    /**
    * name of the forked repository
    */
    'name'?: string;
    /**
    * organization name, if forking into an organization
    */
    'organization'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateForkOption.attributeTypeMap;
    }
}

/**
* CreateGPGKeyOption options create user GPG key
*/
export class CreateGPGKeyOption {
    /**
    * An armored GPG key to add
    */
    'armoredPublicKey': string;
    'armoredSignature'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "armoredPublicKey",
            "baseName": "armored_public_key",
            "type": "string"
        },
        {
            "name": "armoredSignature",
            "baseName": "armored_signature",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateGPGKeyOption.attributeTypeMap;
    }
}

/**
* CreateHookOption options when create a hook
*/
export class CreateHookOption {
    'active'?: boolean;
    'branchFilter'?: string;
    'config': CreateHookOptionConfig;
    'events'?: Array<string>;
    'type': CreateHookOption.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "branchFilter",
            "baseName": "branch_filter",
            "type": "string"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "CreateHookOptionConfig"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<string>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "CreateHookOption.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateHookOption.attributeTypeMap;
    }
}

export namespace CreateHookOption {
    export enum TypeEnum {
        Dingtalk = <any> 'dingtalk',
        Discord = <any> 'discord',
        Gitea = <any> 'gitea',
        Gogs = <any> 'gogs',
        Msteams = <any> 'msteams',
        Slack = <any> 'slack',
        Telegram = <any> 'telegram',
        Feishu = <any> 'feishu',
        Wechatwork = <any> 'wechatwork'
    }
}
/**
* CreateHookOptionConfig has all config options in it required are \"content_type\" and \"url\" Required
*/
export class CreateHookOptionConfig extends null<String, string> {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CreateHookOptionConfig.attributeTypeMap);
    }
}

/**
* CreateIssueCommentOption options for creating a comment on an issue
*/
export class CreateIssueCommentOption {
    'body': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateIssueCommentOption.attributeTypeMap;
    }
}

/**
* CreateIssueOption options to create one issue
*/
export class CreateIssueOption {
    /**
    * deprecated
    */
    'assignee'?: string;
    'assignees'?: Array<string>;
    'body'?: string;
    'closed'?: boolean;
    'dueDate'?: Date;
    /**
    * list of label ids
    */
    'labels'?: Array<number>;
    /**
    * milestone id
    */
    'milestone'?: number;
    'ref'?: string;
    'title': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignee",
            "baseName": "assignee",
            "type": "string"
        },
        {
            "name": "assignees",
            "baseName": "assignees",
            "type": "Array<string>"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "closed",
            "baseName": "closed",
            "type": "boolean"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "Date"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<number>"
        },
        {
            "name": "milestone",
            "baseName": "milestone",
            "type": "number"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateIssueOption.attributeTypeMap;
    }
}

/**
* CreateKeyOption options when creating a key
*/
export class CreateKeyOption {
    /**
    * An armored SSH key to add
    */
    'key': string;
    /**
    * Describe if the key has only read access or read/write
    */
    'readOnly'?: boolean;
    /**
    * Title of the key to add
    */
    'title': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "readOnly",
            "baseName": "read_only",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateKeyOption.attributeTypeMap;
    }
}

/**
* CreateLabelOption options for creating a label
*/
export class CreateLabelOption {
    'color': string;
    'description'?: string;
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateLabelOption.attributeTypeMap;
    }
}

/**
* CreateMilestoneOption options for creating a milestone
*/
export class CreateMilestoneOption {
    'description'?: string;
    'dueOn'?: Date;
    'state'?: CreateMilestoneOption.StateEnum;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueOn",
            "baseName": "due_on",
            "type": "Date"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "CreateMilestoneOption.StateEnum"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateMilestoneOption.attributeTypeMap;
    }
}

export namespace CreateMilestoneOption {
    export enum StateEnum {
        Open = <any> 'open',
        Closed = <any> 'closed'
    }
}
/**
* CreateOAuth2ApplicationOptions holds options to create an oauth2 application
*/
export class CreateOAuth2ApplicationOptions {
    'name'?: string;
    'redirectUris'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "redirectUris",
            "baseName": "redirect_uris",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CreateOAuth2ApplicationOptions.attributeTypeMap;
    }
}

/**
* CreateOrgOption options for creating an organization
*/
export class CreateOrgOption {
    'description'?: string;
    'fullName'?: string;
    'location'?: string;
    'repoAdminChangeTeamAccess'?: boolean;
    'username': string;
    /**
    * possible values are `public` (default), `limited` or `private`
    */
    'visibility'?: CreateOrgOption.VisibilityEnum;
    'website'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "repoAdminChangeTeamAccess",
            "baseName": "repo_admin_change_team_access",
            "type": "boolean"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "CreateOrgOption.VisibilityEnum"
        },
        {
            "name": "website",
            "baseName": "website",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateOrgOption.attributeTypeMap;
    }
}

export namespace CreateOrgOption {
    export enum VisibilityEnum {
        Public = <any> 'public',
        Limited = <any> 'limited',
        Private = <any> 'private'
    }
}
/**
* CreatePullRequestOption options when creating a pull request
*/
export class CreatePullRequestOption {
    'assignee'?: string;
    'assignees'?: Array<string>;
    'base'?: string;
    'body'?: string;
    'dueDate'?: Date;
    'head'?: string;
    'labels'?: Array<number>;
    'milestone'?: number;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignee",
            "baseName": "assignee",
            "type": "string"
        },
        {
            "name": "assignees",
            "baseName": "assignees",
            "type": "Array<string>"
        },
        {
            "name": "base",
            "baseName": "base",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "Date"
        },
        {
            "name": "head",
            "baseName": "head",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<number>"
        },
        {
            "name": "milestone",
            "baseName": "milestone",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreatePullRequestOption.attributeTypeMap;
    }
}

/**
* CreatePullReviewComment represent a review comment for creation api
*/
export class CreatePullReviewComment {
    'body'?: string;
    /**
    * if comment to new file line or 0
    */
    'newPosition'?: number;
    /**
    * if comment to old file line or 0
    */
    'oldPosition'?: number;
    /**
    * the tree path
    */
    'path'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "newPosition",
            "baseName": "new_position",
            "type": "number"
        },
        {
            "name": "oldPosition",
            "baseName": "old_position",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreatePullReviewComment.attributeTypeMap;
    }
}

/**
* CreatePullReviewOptions are options to create a pull review
*/
export class CreatePullReviewOptions {
    'body'?: string;
    'comments'?: Array<CreatePullReviewComment>;
    'commitId'?: string;
    'event'?: ReviewStateType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "Array<CreatePullReviewComment>"
        },
        {
            "name": "commitId",
            "baseName": "commit_id",
            "type": "string"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "ReviewStateType"
        }    ];

    static getAttributeTypeMap() {
        return CreatePullReviewOptions.attributeTypeMap;
    }
}

/**
* CreateReleaseOption options when creating a release
*/
export class CreateReleaseOption {
    'body'?: string;
    'draft'?: boolean;
    'name'?: string;
    'prerelease'?: boolean;
    'tagName': string;
    'targetCommitish'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "draft",
            "baseName": "draft",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "prerelease",
            "baseName": "prerelease",
            "type": "boolean"
        },
        {
            "name": "tagName",
            "baseName": "tag_name",
            "type": "string"
        },
        {
            "name": "targetCommitish",
            "baseName": "target_commitish",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateReleaseOption.attributeTypeMap;
    }
}

/**
* CreateRepoOption options when creating repository
*/
export class CreateRepoOption {
    /**
    * Whether the repository should be auto-initialized?
    */
    'autoInit'?: boolean;
    /**
    * DefaultBranch of the repository (used when initializes and in template)
    */
    'defaultBranch'?: string;
    /**
    * Description of the repository to create
    */
    'description'?: string;
    /**
    * Gitignores to use
    */
    'gitignores'?: string;
    /**
    * Label-Set to use
    */
    'issueLabels'?: string;
    /**
    * License to use
    */
    'license'?: string;
    /**
    * Name of the repository to create
    */
    'name': string;
    /**
    * Whether the repository is private
    */
    '_private'?: boolean;
    /**
    * Readme of the repository to create
    */
    'readme'?: string;
    /**
    * Whether the repository is template
    */
    'template'?: boolean;
    /**
    * TrustModel of the repository
    */
    'trustModel'?: CreateRepoOption.TrustModelEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoInit",
            "baseName": "auto_init",
            "type": "boolean"
        },
        {
            "name": "defaultBranch",
            "baseName": "default_branch",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "gitignores",
            "baseName": "gitignores",
            "type": "string"
        },
        {
            "name": "issueLabels",
            "baseName": "issue_labels",
            "type": "string"
        },
        {
            "name": "license",
            "baseName": "license",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "readme",
            "baseName": "readme",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "boolean"
        },
        {
            "name": "trustModel",
            "baseName": "trust_model",
            "type": "CreateRepoOption.TrustModelEnum"
        }    ];

    static getAttributeTypeMap() {
        return CreateRepoOption.attributeTypeMap;
    }
}

export namespace CreateRepoOption {
    export enum TrustModelEnum {
        Default = <any> 'default',
        Collaborator = <any> 'collaborator',
        Committer = <any> 'committer',
        Collaboratorcommitter = <any> 'collaboratorcommitter'
    }
}
/**
* CreateStatusOption holds the information needed to create a new CommitStatus for a Commit
*/
export class CreateStatusOption {
    'context'?: string;
    'description'?: string;
    'state'?: CommitStatusState;
    'targetUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "CommitStatusState"
        },
        {
            "name": "targetUrl",
            "baseName": "target_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateStatusOption.attributeTypeMap;
    }
}

/**
* CreateTagOption options when creating a tag
*/
export class CreateTagOption {
    'message'?: string;
    'tagName': string;
    'target'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "tagName",
            "baseName": "tag_name",
            "type": "string"
        },
        {
            "name": "target",
            "baseName": "target",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateTagOption.attributeTypeMap;
    }
}

/**
* CreateTeamOption options for creating a team
*/
export class CreateTeamOption {
    'canCreateOrgRepo'?: boolean;
    'description'?: string;
    'includesAllRepositories'?: boolean;
    'name': string;
    'permission'?: CreateTeamOption.PermissionEnum;
    'units'?: Array<string>;
    'unitsMap'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "canCreateOrgRepo",
            "baseName": "can_create_org_repo",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "includesAllRepositories",
            "baseName": "includes_all_repositories",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "permission",
            "baseName": "permission",
            "type": "CreateTeamOption.PermissionEnum"
        },
        {
            "name": "units",
            "baseName": "units",
            "type": "Array<string>"
        },
        {
            "name": "unitsMap",
            "baseName": "units_map",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return CreateTeamOption.attributeTypeMap;
    }
}

export namespace CreateTeamOption {
    export enum PermissionEnum {
        Read = <any> 'read',
        Write = <any> 'write',
        Admin = <any> 'admin'
    }
}
/**
* CreateUserOption create user options
*/
export class CreateUserOption {
    'email': string;
    'fullName'?: string;
    'loginName'?: string;
    'mustChangePassword'?: boolean;
    'password': string;
    'sendNotify'?: boolean;
    'sourceId'?: number;
    'username': string;
    'visibility'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "loginName",
            "baseName": "login_name",
            "type": "string"
        },
        {
            "name": "mustChangePassword",
            "baseName": "must_change_password",
            "type": "boolean"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "sendNotify",
            "baseName": "send_notify",
            "type": "boolean"
        },
        {
            "name": "sourceId",
            "baseName": "source_id",
            "type": "number"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateUserOption.attributeTypeMap;
    }
}

/**
* CreateWikiPageOptions form for creating wiki
*/
export class CreateWikiPageOptions {
    /**
    * content must be base64 encoded
    */
    'contentBase64'?: string;
    /**
    * optional commit message summarizing the change
    */
    'message'?: string;
    /**
    * page title. leave empty to keep unchanged
    */
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contentBase64",
            "baseName": "content_base64",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateWikiPageOptions.attributeTypeMap;
    }
}

/**
* Cron represents a Cron task
*/
export class Cron {
    'execTimes'?: number;
    'name'?: string;
    'next'?: Date;
    'prev'?: Date;
    'schedule'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "execTimes",
            "baseName": "exec_times",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "Date"
        },
        {
            "name": "prev",
            "baseName": "prev",
            "type": "Date"
        },
        {
            "name": "schedule",
            "baseName": "schedule",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Cron.attributeTypeMap;
    }
}

/**
* DeleteEmailOption options when deleting email addresses
*/
export class DeleteEmailOption {
    /**
    * email addresses to delete
    */
    'emails'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emails",
            "baseName": "emails",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return DeleteEmailOption.attributeTypeMap;
    }
}

/**
* DeleteFileOptions options for deleting files (used for other File structs below) Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
*/
export class DeleteFileOptions {
    'author'?: Identity;
    /**
    * branch (optional) to base this file from. if not given, the default branch is used
    */
    'branch'?: string;
    'committer'?: Identity;
    'dates'?: CommitDateOptions;
    /**
    * message (optional) for the commit of this file. if not supplied, a default message will be used
    */
    'message'?: string;
    /**
    * new_branch (optional) will make a new branch from `branch` before creating the file
    */
    'newBranch'?: string;
    /**
    * sha is the SHA for the file that already exists
    */
    'sha': string;
    /**
    * Add a Signed-off-by trailer by the committer at the end of the commit log message.
    */
    'signoff'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "Identity"
        },
        {
            "name": "branch",
            "baseName": "branch",
            "type": "string"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "Identity"
        },
        {
            "name": "dates",
            "baseName": "dates",
            "type": "CommitDateOptions"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "newBranch",
            "baseName": "new_branch",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "signoff",
            "baseName": "signoff",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DeleteFileOptions.attributeTypeMap;
    }
}

/**
* DeployKey a deploy key
*/
export class DeployKey {
    'createdAt'?: Date;
    'fingerprint'?: string;
    'id'?: number;
    'key'?: string;
    'keyId'?: number;
    'readOnly'?: boolean;
    'repository'?: Repository;
    'title'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "fingerprint",
            "baseName": "fingerprint",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "keyId",
            "baseName": "key_id",
            "type": "number"
        },
        {
            "name": "readOnly",
            "baseName": "read_only",
            "type": "boolean"
        },
        {
            "name": "repository",
            "baseName": "repository",
            "type": "Repository"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeployKey.attributeTypeMap;
    }
}

/**
* DismissPullReviewOptions are options to dismiss a pull review
*/
export class DismissPullReviewOptions {
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DismissPullReviewOptions.attributeTypeMap;
    }
}

/**
* EditAttachmentOptions options for editing attachments
*/
export class EditAttachmentOptions {
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditAttachmentOptions.attributeTypeMap;
    }
}

/**
* EditBranchProtectionOption options for editing a branch protection
*/
export class EditBranchProtectionOption {
    'approvalsWhitelistTeams'?: Array<string>;
    'approvalsWhitelistUsername'?: Array<string>;
    'blockOnOfficialReviewRequests'?: boolean;
    'blockOnOutdatedBranch'?: boolean;
    'blockOnRejectedReviews'?: boolean;
    'dismissStaleApprovals'?: boolean;
    'enableApprovalsWhitelist'?: boolean;
    'enableMergeWhitelist'?: boolean;
    'enablePush'?: boolean;
    'enablePushWhitelist'?: boolean;
    'enableStatusCheck'?: boolean;
    'mergeWhitelistTeams'?: Array<string>;
    'mergeWhitelistUsernames'?: Array<string>;
    'protectedFilePatterns'?: string;
    'pushWhitelistDeployKeys'?: boolean;
    'pushWhitelistTeams'?: Array<string>;
    'pushWhitelistUsernames'?: Array<string>;
    'requireSignedCommits'?: boolean;
    'requiredApprovals'?: number;
    'statusCheckContexts'?: Array<string>;
    'unprotectedFilePatterns'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "approvalsWhitelistTeams",
            "baseName": "approvals_whitelist_teams",
            "type": "Array<string>"
        },
        {
            "name": "approvalsWhitelistUsername",
            "baseName": "approvals_whitelist_username",
            "type": "Array<string>"
        },
        {
            "name": "blockOnOfficialReviewRequests",
            "baseName": "block_on_official_review_requests",
            "type": "boolean"
        },
        {
            "name": "blockOnOutdatedBranch",
            "baseName": "block_on_outdated_branch",
            "type": "boolean"
        },
        {
            "name": "blockOnRejectedReviews",
            "baseName": "block_on_rejected_reviews",
            "type": "boolean"
        },
        {
            "name": "dismissStaleApprovals",
            "baseName": "dismiss_stale_approvals",
            "type": "boolean"
        },
        {
            "name": "enableApprovalsWhitelist",
            "baseName": "enable_approvals_whitelist",
            "type": "boolean"
        },
        {
            "name": "enableMergeWhitelist",
            "baseName": "enable_merge_whitelist",
            "type": "boolean"
        },
        {
            "name": "enablePush",
            "baseName": "enable_push",
            "type": "boolean"
        },
        {
            "name": "enablePushWhitelist",
            "baseName": "enable_push_whitelist",
            "type": "boolean"
        },
        {
            "name": "enableStatusCheck",
            "baseName": "enable_status_check",
            "type": "boolean"
        },
        {
            "name": "mergeWhitelistTeams",
            "baseName": "merge_whitelist_teams",
            "type": "Array<string>"
        },
        {
            "name": "mergeWhitelistUsernames",
            "baseName": "merge_whitelist_usernames",
            "type": "Array<string>"
        },
        {
            "name": "protectedFilePatterns",
            "baseName": "protected_file_patterns",
            "type": "string"
        },
        {
            "name": "pushWhitelistDeployKeys",
            "baseName": "push_whitelist_deploy_keys",
            "type": "boolean"
        },
        {
            "name": "pushWhitelistTeams",
            "baseName": "push_whitelist_teams",
            "type": "Array<string>"
        },
        {
            "name": "pushWhitelistUsernames",
            "baseName": "push_whitelist_usernames",
            "type": "Array<string>"
        },
        {
            "name": "requireSignedCommits",
            "baseName": "require_signed_commits",
            "type": "boolean"
        },
        {
            "name": "requiredApprovals",
            "baseName": "required_approvals",
            "type": "number"
        },
        {
            "name": "statusCheckContexts",
            "baseName": "status_check_contexts",
            "type": "Array<string>"
        },
        {
            "name": "unprotectedFilePatterns",
            "baseName": "unprotected_file_patterns",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditBranchProtectionOption.attributeTypeMap;
    }
}

/**
* EditDeadlineOption options for creating a deadline
*/
export class EditDeadlineOption {
    'dueDate': Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return EditDeadlineOption.attributeTypeMap;
    }
}

/**
* EditGitHookOption options when modifying one Git hook
*/
export class EditGitHookOption {
    'content'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditGitHookOption.attributeTypeMap;
    }
}

/**
* EditHookOption options when modify one hook
*/
export class EditHookOption {
    'active'?: boolean;
    'branchFilter'?: string;
    'config'?: { [key: string]: string; };
    'events'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "branchFilter",
            "baseName": "branch_filter",
            "type": "string"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return EditHookOption.attributeTypeMap;
    }
}

/**
* EditIssueCommentOption options for editing a comment
*/
export class EditIssueCommentOption {
    'body': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditIssueCommentOption.attributeTypeMap;
    }
}

/**
* EditIssueOption options for editing an issue
*/
export class EditIssueOption {
    /**
    * deprecated
    */
    'assignee'?: string;
    'assignees'?: Array<string>;
    'body'?: string;
    'dueDate'?: Date;
    'milestone'?: number;
    'ref'?: string;
    'state'?: string;
    'title'?: string;
    'unsetDueDate'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignee",
            "baseName": "assignee",
            "type": "string"
        },
        {
            "name": "assignees",
            "baseName": "assignees",
            "type": "Array<string>"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "Date"
        },
        {
            "name": "milestone",
            "baseName": "milestone",
            "type": "number"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "unsetDueDate",
            "baseName": "unset_due_date",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EditIssueOption.attributeTypeMap;
    }
}

/**
* EditLabelOption options for editing a label
*/
export class EditLabelOption {
    'color'?: string;
    'description'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditLabelOption.attributeTypeMap;
    }
}

/**
* EditMilestoneOption options for editing a milestone
*/
export class EditMilestoneOption {
    'description'?: string;
    'dueOn'?: Date;
    'state'?: string;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueOn",
            "baseName": "due_on",
            "type": "Date"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditMilestoneOption.attributeTypeMap;
    }
}

/**
* EditOrgOption options for editing an organization
*/
export class EditOrgOption {
    'description'?: string;
    'fullName'?: string;
    'location'?: string;
    'repoAdminChangeTeamAccess'?: boolean;
    /**
    * possible values are `public`, `limited` or `private`
    */
    'visibility'?: EditOrgOption.VisibilityEnum;
    'website'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "repoAdminChangeTeamAccess",
            "baseName": "repo_admin_change_team_access",
            "type": "boolean"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "EditOrgOption.VisibilityEnum"
        },
        {
            "name": "website",
            "baseName": "website",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditOrgOption.attributeTypeMap;
    }
}

export namespace EditOrgOption {
    export enum VisibilityEnum {
        Public = <any> 'public',
        Limited = <any> 'limited',
        Private = <any> 'private'
    }
}
/**
* EditPullRequestOption options when modify pull request
*/
export class EditPullRequestOption {
    'assignee'?: string;
    'assignees'?: Array<string>;
    'base'?: string;
    'body'?: string;
    'dueDate'?: Date;
    'labels'?: Array<number>;
    'milestone'?: number;
    'state'?: string;
    'title'?: string;
    'unsetDueDate'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignee",
            "baseName": "assignee",
            "type": "string"
        },
        {
            "name": "assignees",
            "baseName": "assignees",
            "type": "Array<string>"
        },
        {
            "name": "base",
            "baseName": "base",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "Date"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<number>"
        },
        {
            "name": "milestone",
            "baseName": "milestone",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "unsetDueDate",
            "baseName": "unset_due_date",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EditPullRequestOption.attributeTypeMap;
    }
}

/**
* EditReactionOption contain the reaction type
*/
export class EditReactionOption {
    'content'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditReactionOption.attributeTypeMap;
    }
}

/**
* EditReleaseOption options when editing a release
*/
export class EditReleaseOption {
    'body'?: string;
    'draft'?: boolean;
    'name'?: string;
    'prerelease'?: boolean;
    'tagName'?: string;
    'targetCommitish'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "draft",
            "baseName": "draft",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "prerelease",
            "baseName": "prerelease",
            "type": "boolean"
        },
        {
            "name": "tagName",
            "baseName": "tag_name",
            "type": "string"
        },
        {
            "name": "targetCommitish",
            "baseName": "target_commitish",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditReleaseOption.attributeTypeMap;
    }
}

/**
* EditRepoOption options when editing a repository's properties
*/
export class EditRepoOption {
    /**
    * either `true` to allow mark pr as merged manually, or `false` to prevent it. `has_pull_requests` must be `true`.
    */
    'allowManualMerge'?: boolean;
    /**
    * either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits. `has_pull_requests` must be `true`.
    */
    'allowMergeCommits'?: boolean;
    /**
    * either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging. `has_pull_requests` must be `true`.
    */
    'allowRebase'?: boolean;
    /**
    * either `true` to allow rebase with explicit merge commits (--no-ff), or `false` to prevent rebase with explicit merge commits. `has_pull_requests` must be `true`.
    */
    'allowRebaseExplicit'?: boolean;
    /**
    * either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging. `has_pull_requests` must be `true`.
    */
    'allowSquashMerge'?: boolean;
    /**
    * set to `true` to archive this repository.
    */
    'archived'?: boolean;
    /**
    * either `true` to enable AutodetectManualMerge, or `false` to prevent it. `has_pull_requests` must be `true`, Note: In some special cases, misjudgments can occur.
    */
    'autodetectManualMerge'?: boolean;
    /**
    * sets the default branch for this repository.
    */
    'defaultBranch'?: string;
    /**
    * set to `true` to delete pr branch after merge by default
    */
    'defaultDeleteBranchAfterMerge'?: boolean;
    /**
    * set to a merge style to be used by this repository: \"merge\", \"rebase\", \"rebase-merge\", or \"squash\". `has_pull_requests` must be `true`.
    */
    'defaultMergeStyle'?: string;
    /**
    * a short description of the repository.
    */
    'description'?: string;
    'externalTracker'?: ExternalTracker;
    'externalWiki'?: ExternalWiki;
    /**
    * either `true` to enable issues for this repository or `false` to disable them.
    */
    'hasIssues'?: boolean;
    /**
    * either `true` to enable project unit, or `false` to disable them.
    */
    'hasProjects'?: boolean;
    /**
    * either `true` to allow pull requests, or `false` to prevent pull request.
    */
    'hasPullRequests'?: boolean;
    /**
    * either `true` to enable the wiki for this repository or `false` to disable it.
    */
    'hasWiki'?: boolean;
    /**
    * either `true` to ignore whitespace for conflicts, or `false` to not ignore whitespace. `has_pull_requests` must be `true`.
    */
    'ignoreWhitespaceConflicts'?: boolean;
    'internalTracker'?: InternalTracker;
    /**
    * set to a string like `8h30m0s` to set the mirror interval time
    */
    'mirrorInterval'?: string;
    /**
    * name of the repository
    */
    'name'?: string;
    /**
    * either `true` to make the repository private or `false` to make it public. Note: you will get a 422 error if the organization restricts changing repository visibility to organization owners and a non-owner tries to change the value of private.
    */
    '_private'?: boolean;
    /**
    * either `true` to make this repository a template or `false` to make it a normal repository
    */
    'template'?: boolean;
    /**
    * a URL with more information about the repository.
    */
    'website'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowManualMerge",
            "baseName": "allow_manual_merge",
            "type": "boolean"
        },
        {
            "name": "allowMergeCommits",
            "baseName": "allow_merge_commits",
            "type": "boolean"
        },
        {
            "name": "allowRebase",
            "baseName": "allow_rebase",
            "type": "boolean"
        },
        {
            "name": "allowRebaseExplicit",
            "baseName": "allow_rebase_explicit",
            "type": "boolean"
        },
        {
            "name": "allowSquashMerge",
            "baseName": "allow_squash_merge",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "autodetectManualMerge",
            "baseName": "autodetect_manual_merge",
            "type": "boolean"
        },
        {
            "name": "defaultBranch",
            "baseName": "default_branch",
            "type": "string"
        },
        {
            "name": "defaultDeleteBranchAfterMerge",
            "baseName": "default_delete_branch_after_merge",
            "type": "boolean"
        },
        {
            "name": "defaultMergeStyle",
            "baseName": "default_merge_style",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "externalTracker",
            "baseName": "external_tracker",
            "type": "ExternalTracker"
        },
        {
            "name": "externalWiki",
            "baseName": "external_wiki",
            "type": "ExternalWiki"
        },
        {
            "name": "hasIssues",
            "baseName": "has_issues",
            "type": "boolean"
        },
        {
            "name": "hasProjects",
            "baseName": "has_projects",
            "type": "boolean"
        },
        {
            "name": "hasPullRequests",
            "baseName": "has_pull_requests",
            "type": "boolean"
        },
        {
            "name": "hasWiki",
            "baseName": "has_wiki",
            "type": "boolean"
        },
        {
            "name": "ignoreWhitespaceConflicts",
            "baseName": "ignore_whitespace_conflicts",
            "type": "boolean"
        },
        {
            "name": "internalTracker",
            "baseName": "internal_tracker",
            "type": "InternalTracker"
        },
        {
            "name": "mirrorInterval",
            "baseName": "mirror_interval",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "boolean"
        },
        {
            "name": "website",
            "baseName": "website",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditRepoOption.attributeTypeMap;
    }
}

/**
* EditTeamOption options for editing a team
*/
export class EditTeamOption {
    'canCreateOrgRepo'?: boolean;
    'description'?: string;
    'includesAllRepositories'?: boolean;
    'name': string;
    'permission'?: EditTeamOption.PermissionEnum;
    'units'?: Array<string>;
    'unitsMap'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "canCreateOrgRepo",
            "baseName": "can_create_org_repo",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "includesAllRepositories",
            "baseName": "includes_all_repositories",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "permission",
            "baseName": "permission",
            "type": "EditTeamOption.PermissionEnum"
        },
        {
            "name": "units",
            "baseName": "units",
            "type": "Array<string>"
        },
        {
            "name": "unitsMap",
            "baseName": "units_map",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return EditTeamOption.attributeTypeMap;
    }
}

export namespace EditTeamOption {
    export enum PermissionEnum {
        Read = <any> 'read',
        Write = <any> 'write',
        Admin = <any> 'admin'
    }
}
/**
* EditUserOption edit user options
*/
export class EditUserOption {
    'active'?: boolean;
    'admin'?: boolean;
    'allowCreateOrganization'?: boolean;
    'allowGitHook'?: boolean;
    'allowImportLocal'?: boolean;
    'description'?: string;
    'email'?: string;
    'fullName'?: string;
    'location'?: string;
    'loginName': string;
    'maxRepoCreation'?: number;
    'mustChangePassword'?: boolean;
    'password'?: string;
    'prohibitLogin'?: boolean;
    'restricted'?: boolean;
    'sourceId': number;
    'visibility'?: string;
    'website'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "admin",
            "baseName": "admin",
            "type": "boolean"
        },
        {
            "name": "allowCreateOrganization",
            "baseName": "allow_create_organization",
            "type": "boolean"
        },
        {
            "name": "allowGitHook",
            "baseName": "allow_git_hook",
            "type": "boolean"
        },
        {
            "name": "allowImportLocal",
            "baseName": "allow_import_local",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "loginName",
            "baseName": "login_name",
            "type": "string"
        },
        {
            "name": "maxRepoCreation",
            "baseName": "max_repo_creation",
            "type": "number"
        },
        {
            "name": "mustChangePassword",
            "baseName": "must_change_password",
            "type": "boolean"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "prohibitLogin",
            "baseName": "prohibit_login",
            "type": "boolean"
        },
        {
            "name": "restricted",
            "baseName": "restricted",
            "type": "boolean"
        },
        {
            "name": "sourceId",
            "baseName": "source_id",
            "type": "number"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "string"
        },
        {
            "name": "website",
            "baseName": "website",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditUserOption.attributeTypeMap;
    }
}

/**
* Email an email address belonging to a user
*/
export class Email {
    'email'?: string;
    'primary'?: boolean;
    'verified'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "primary",
            "baseName": "primary",
            "type": "boolean"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Email.attributeTypeMap;
    }
}

/**
* ExternalTracker represents settings for external tracker
*/
export class ExternalTracker {
    /**
    * External Issue Tracker URL Format. Use the placeholders {user}, {repo} and {index} for the username, repository name and issue index.
    */
    'externalTrackerFormat'?: string;
    /**
    * External Issue Tracker Number Format, either `numeric` or `alphanumeric`
    */
    'externalTrackerStyle'?: string;
    /**
    * URL of external issue tracker.
    */
    'externalTrackerUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "externalTrackerFormat",
            "baseName": "external_tracker_format",
            "type": "string"
        },
        {
            "name": "externalTrackerStyle",
            "baseName": "external_tracker_style",
            "type": "string"
        },
        {
            "name": "externalTrackerUrl",
            "baseName": "external_tracker_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExternalTracker.attributeTypeMap;
    }
}

/**
* ExternalWiki represents setting for external wiki
*/
export class ExternalWiki {
    /**
    * URL of external wiki.
    */
    'externalWikiUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "externalWikiUrl",
            "baseName": "external_wiki_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExternalWiki.attributeTypeMap;
    }
}

export class FileCommitResponse {
    'author'?: CommitUser;
    'committer'?: CommitUser;
    'created'?: Date;
    'htmlUrl'?: string;
    'message'?: string;
    'parents'?: Array<CommitMeta>;
    'sha'?: string;
    'tree'?: CommitMeta;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "CommitUser"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "CommitUser"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "Array<CommitMeta>"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "CommitMeta"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FileCommitResponse.attributeTypeMap;
    }
}

/**
* FileDeleteResponse contains information about a repo's file that was deleted
*/
export class FileDeleteResponse {
    'commit'?: FileCommitResponse;
    'content'?: any;
    'verification'?: PayloadCommitVerification;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commit",
            "baseName": "commit",
            "type": "FileCommitResponse"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "any"
        },
        {
            "name": "verification",
            "baseName": "verification",
            "type": "PayloadCommitVerification"
        }    ];

    static getAttributeTypeMap() {
        return FileDeleteResponse.attributeTypeMap;
    }
}

/**
* FileLinksResponse contains the links for a repo's file
*/
export class FileLinksResponse {
    'git'?: string;
    'html'?: string;
    'self'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "git",
            "baseName": "git",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FileLinksResponse.attributeTypeMap;
    }
}

/**
* FileResponse contains information about a repo's file
*/
export class FileResponse {
    'commit'?: FileCommitResponse;
    'content'?: ContentsResponse;
    'verification'?: PayloadCommitVerification;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commit",
            "baseName": "commit",
            "type": "FileCommitResponse"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "ContentsResponse"
        },
        {
            "name": "verification",
            "baseName": "verification",
            "type": "PayloadCommitVerification"
        }    ];

    static getAttributeTypeMap() {
        return FileResponse.attributeTypeMap;
    }
}

/**
* GPGKey a user GPG key to sign commit and tag in repository
*/
export class GPGKey {
    'canCertify'?: boolean;
    'canEncryptComms'?: boolean;
    'canEncryptStorage'?: boolean;
    'canSign'?: boolean;
    'createdAt'?: Date;
    'emails'?: Array<GPGKeyEmail>;
    'expiresAt'?: Date;
    'id'?: number;
    'keyId'?: string;
    'primaryKeyId'?: string;
    'publicKey'?: string;
    'subkeys'?: Array<GPGKey>;
    'verified'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "canCertify",
            "baseName": "can_certify",
            "type": "boolean"
        },
        {
            "name": "canEncryptComms",
            "baseName": "can_encrypt_comms",
            "type": "boolean"
        },
        {
            "name": "canEncryptStorage",
            "baseName": "can_encrypt_storage",
            "type": "boolean"
        },
        {
            "name": "canSign",
            "baseName": "can_sign",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "emails",
            "baseName": "emails",
            "type": "Array<GPGKeyEmail>"
        },
        {
            "name": "expiresAt",
            "baseName": "expires_at",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "keyId",
            "baseName": "key_id",
            "type": "string"
        },
        {
            "name": "primaryKeyId",
            "baseName": "primary_key_id",
            "type": "string"
        },
        {
            "name": "publicKey",
            "baseName": "public_key",
            "type": "string"
        },
        {
            "name": "subkeys",
            "baseName": "subkeys",
            "type": "Array<GPGKey>"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GPGKey.attributeTypeMap;
    }
}

/**
* GPGKeyEmail an email attached to a GPGKey
*/
export class GPGKeyEmail {
    'email'?: string;
    'verified'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GPGKeyEmail.attributeTypeMap;
    }
}

/**
* GeneralAPISettings contains global api settings exposed by it
*/
export class GeneralAPISettings {
    'defaultGitTreesPerPage'?: number;
    'defaultMaxBlobSize'?: number;
    'defaultPagingNum'?: number;
    'maxResponseItems'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "defaultGitTreesPerPage",
            "baseName": "default_git_trees_per_page",
            "type": "number"
        },
        {
            "name": "defaultMaxBlobSize",
            "baseName": "default_max_blob_size",
            "type": "number"
        },
        {
            "name": "defaultPagingNum",
            "baseName": "default_paging_num",
            "type": "number"
        },
        {
            "name": "maxResponseItems",
            "baseName": "max_response_items",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GeneralAPISettings.attributeTypeMap;
    }
}

/**
* GeneralAttachmentSettings contains global Attachment settings exposed by API
*/
export class GeneralAttachmentSettings {
    'allowedTypes'?: string;
    'enabled'?: boolean;
    'maxFiles'?: number;
    'maxSize'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowedTypes",
            "baseName": "allowed_types",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "maxFiles",
            "baseName": "max_files",
            "type": "number"
        },
        {
            "name": "maxSize",
            "baseName": "max_size",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GeneralAttachmentSettings.attributeTypeMap;
    }
}

/**
* GeneralRepoSettings contains global repository settings exposed by API
*/
export class GeneralRepoSettings {
    'httpGitDisabled'?: boolean;
    'lfsDisabled'?: boolean;
    'migrationsDisabled'?: boolean;
    'mirrorsDisabled'?: boolean;
    'starsDisabled'?: boolean;
    'timeTrackingDisabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "httpGitDisabled",
            "baseName": "http_git_disabled",
            "type": "boolean"
        },
        {
            "name": "lfsDisabled",
            "baseName": "lfs_disabled",
            "type": "boolean"
        },
        {
            "name": "migrationsDisabled",
            "baseName": "migrations_disabled",
            "type": "boolean"
        },
        {
            "name": "mirrorsDisabled",
            "baseName": "mirrors_disabled",
            "type": "boolean"
        },
        {
            "name": "starsDisabled",
            "baseName": "stars_disabled",
            "type": "boolean"
        },
        {
            "name": "timeTrackingDisabled",
            "baseName": "time_tracking_disabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GeneralRepoSettings.attributeTypeMap;
    }
}

/**
* GeneralUISettings contains global ui settings exposed by API
*/
export class GeneralUISettings {
    'allowedReactions'?: Array<string>;
    'customEmojis'?: Array<string>;
    'defaultTheme'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowedReactions",
            "baseName": "allowed_reactions",
            "type": "Array<string>"
        },
        {
            "name": "customEmojis",
            "baseName": "custom_emojis",
            "type": "Array<string>"
        },
        {
            "name": "defaultTheme",
            "baseName": "default_theme",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GeneralUISettings.attributeTypeMap;
    }
}

/**
* GenerateRepoOption options when creating repository using a template
*/
export class GenerateRepoOption {
    /**
    * include avatar of the template repo
    */
    'avatar'?: boolean;
    /**
    * Description of the repository to create
    */
    'description'?: string;
    /**
    * include git content of default branch in template repo
    */
    'gitContent'?: boolean;
    /**
    * include git hooks in template repo
    */
    'gitHooks'?: boolean;
    /**
    * include labels in template repo
    */
    'labels'?: boolean;
    /**
    * Name of the repository to create
    */
    'name': string;
    /**
    * The organization or person who will own the new repository
    */
    'owner': string;
    /**
    * Whether the repository is private
    */
    '_private'?: boolean;
    /**
    * include topics in template repo
    */
    'topics'?: boolean;
    /**
    * include webhooks in template repo
    */
    'webhooks'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avatar",
            "baseName": "avatar",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "gitContent",
            "baseName": "git_content",
            "type": "boolean"
        },
        {
            "name": "gitHooks",
            "baseName": "git_hooks",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "topics",
            "baseName": "topics",
            "type": "boolean"
        },
        {
            "name": "webhooks",
            "baseName": "webhooks",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return GenerateRepoOption.attributeTypeMap;
    }
}

/**
* GitBlobResponse represents a git blob
*/
export class GitBlobResponse {
    'content'?: string;
    'encoding'?: string;
    'sha'?: string;
    'size'?: number;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "encoding",
            "baseName": "encoding",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GitBlobResponse.attributeTypeMap;
    }
}

/**
* GitEntry represents a git tree
*/
export class GitEntry {
    'mode'?: string;
    'path'?: string;
    'sha'?: string;
    'size'?: number;
    'type'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mode",
            "baseName": "mode",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GitEntry.attributeTypeMap;
    }
}

/**
* GitHook represents a Git repository hook
*/
export class GitHook {
    'content'?: string;
    'isActive'?: boolean;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "isActive",
            "baseName": "is_active",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GitHook.attributeTypeMap;
    }
}

export class GitObject {
    'sha'?: string;
    'type'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GitObject.attributeTypeMap;
    }
}

/**
* GitServiceType represents a git service
*/
export class GitServiceType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return GitServiceType.attributeTypeMap;
    }
}

/**
* GitTreeResponse returns a git tree
*/
export class GitTreeResponse {
    'page'?: number;
    'sha'?: string;
    'totalCount'?: number;
    'tree'?: Array<GitEntry>;
    'truncated'?: boolean;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "page",
            "baseName": "page",
            "type": "number"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "totalCount",
            "baseName": "total_count",
            "type": "number"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "Array<GitEntry>"
        },
        {
            "name": "truncated",
            "baseName": "truncated",
            "type": "boolean"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GitTreeResponse.attributeTypeMap;
    }
}

/**
* Hook a hook is a web hook when one repository changed
*/
export class Hook {
    'active'?: boolean;
    'config'?: { [key: string]: string; };
    'createdAt'?: Date;
    'events'?: Array<string>;
    'id'?: number;
    'type'?: string;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<string>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Hook.attributeTypeMap;
    }
}

/**
* Identity for a person's identity like an author or committer
*/
export class Identity {
    'email'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Identity.attributeTypeMap;
    }
}

/**
* InternalTracker represents settings for internal tracker
*/
export class InternalTracker {
    /**
    * Let only contributors track time (Built-in issue tracker)
    */
    'allowOnlyContributorsToTrackTime'?: boolean;
    /**
    * Enable dependencies for issues and pull requests (Built-in issue tracker)
    */
    'enableIssueDependencies'?: boolean;
    /**
    * Enable time tracking (Built-in issue tracker)
    */
    'enableTimeTracker'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowOnlyContributorsToTrackTime",
            "baseName": "allow_only_contributors_to_track_time",
            "type": "boolean"
        },
        {
            "name": "enableIssueDependencies",
            "baseName": "enable_issue_dependencies",
            "type": "boolean"
        },
        {
            "name": "enableTimeTracker",
            "baseName": "enable_time_tracker",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InternalTracker.attributeTypeMap;
    }
}

/**
* Issue represents an issue in a repository
*/
export class Issue {
    'assignee'?: User;
    'assignees'?: Array<User>;
    'body'?: string;
    'closedAt'?: Date;
    'comments'?: number;
    'createdAt'?: Date;
    'dueDate'?: Date;
    'htmlUrl'?: string;
    'id'?: number;
    'isLocked'?: boolean;
    'labels'?: Array<Label>;
    'milestone'?: Milestone;
    'number'?: number;
    'originalAuthor'?: string;
    'originalAuthorId'?: number;
    'pullRequest'?: PullRequestMeta;
    'ref'?: string;
    'repository'?: RepositoryMeta;
    'state'?: StateType;
    'title'?: string;
    'updatedAt'?: Date;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignee",
            "baseName": "assignee",
            "type": "User"
        },
        {
            "name": "assignees",
            "baseName": "assignees",
            "type": "Array<User>"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "closedAt",
            "baseName": "closed_at",
            "type": "Date"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "Date"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "isLocked",
            "baseName": "is_locked",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<Label>"
        },
        {
            "name": "milestone",
            "baseName": "milestone",
            "type": "Milestone"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "originalAuthor",
            "baseName": "original_author",
            "type": "string"
        },
        {
            "name": "originalAuthorId",
            "baseName": "original_author_id",
            "type": "number"
        },
        {
            "name": "pullRequest",
            "baseName": "pull_request",
            "type": "PullRequestMeta"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "repository",
            "baseName": "repository",
            "type": "RepositoryMeta"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "StateType"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return Issue.attributeTypeMap;
    }
}

/**
* IssueDeadline represents an issue deadline
*/
export class IssueDeadline {
    'dueDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return IssueDeadline.attributeTypeMap;
    }
}

/**
* IssueLabelsOption a collection of labels
*/
export class IssueLabelsOption {
    /**
    * list of label IDs
    */
    'labels'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return IssueLabelsOption.attributeTypeMap;
    }
}

/**
* IssueTemplate represents an issue template for a repository
*/
export class IssueTemplate {
    'about'?: string;
    'content'?: string;
    'fileName'?: string;
    'labels'?: Array<string>;
    'name'?: string;
    'ref'?: string;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "about",
            "baseName": "about",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "fileName",
            "baseName": "file_name",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssueTemplate.attributeTypeMap;
    }
}

/**
* Label a label to an issue or a pr
*/
export class Label {
    'color'?: string;
    'description'?: string;
    'id'?: number;
    'name'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Label.attributeTypeMap;
    }
}

/**
* MarkdownOption markdown options
*/
export class MarkdownOption {
    /**
    * Context to render  in: body
    */
    'context'?: string;
    /**
    * Mode to render  in: body
    */
    'mode'?: string;
    /**
    * Text markdown to render  in: body
    */
    'text'?: string;
    /**
    * Is it a wiki page ?  in: body
    */
    'wiki'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "Context",
            "type": "string"
        },
        {
            "name": "mode",
            "baseName": "Mode",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "Text",
            "type": "string"
        },
        {
            "name": "wiki",
            "baseName": "Wiki",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MarkdownOption.attributeTypeMap;
    }
}

/**
* MergePullRequestForm form for merging Pull Request
*/
export class MergePullRequestOption {
    '_do': MergePullRequestOption.DoEnum;
    'mergeCommitID'?: string;
    'mergeMessageField'?: string;
    'mergeTitleField'?: string;
    'deleteBranchAfterMerge'?: boolean;
    'forceMerge'?: boolean;
    'headCommitId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_do",
            "baseName": "Do",
            "type": "MergePullRequestOption.DoEnum"
        },
        {
            "name": "mergeCommitID",
            "baseName": "MergeCommitID",
            "type": "string"
        },
        {
            "name": "mergeMessageField",
            "baseName": "MergeMessageField",
            "type": "string"
        },
        {
            "name": "mergeTitleField",
            "baseName": "MergeTitleField",
            "type": "string"
        },
        {
            "name": "deleteBranchAfterMerge",
            "baseName": "delete_branch_after_merge",
            "type": "boolean"
        },
        {
            "name": "forceMerge",
            "baseName": "force_merge",
            "type": "boolean"
        },
        {
            "name": "headCommitId",
            "baseName": "head_commit_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MergePullRequestOption.attributeTypeMap;
    }
}

export namespace MergePullRequestOption {
    export enum DoEnum {
        Merge = <any> 'merge',
        Rebase = <any> 'rebase',
        RebaseMerge = <any> 'rebase-merge',
        Squash = <any> 'squash',
        ManuallyMerged = <any> 'manually-merged'
    }
}
/**
* MigrateRepoForm form for migrating repository this is used to interact with web ui
*/
export class MigrateRepoForm {
    'authPassword'?: string;
    'authToken'?: string;
    'authUsername'?: string;
    'cloneAddr': string;
    'description'?: string;
    'issues'?: boolean;
    'labels'?: boolean;
    'lfs'?: boolean;
    'lfsEndpoint'?: string;
    'milestones'?: boolean;
    'mirror'?: boolean;
    'mirrorInterval'?: string;
    '_private'?: boolean;
    'pullRequests'?: boolean;
    'releases'?: boolean;
    'repoName': string;
    'service'?: GitServiceType;
    'uid': number;
    'wiki'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authPassword",
            "baseName": "auth_password",
            "type": "string"
        },
        {
            "name": "authToken",
            "baseName": "auth_token",
            "type": "string"
        },
        {
            "name": "authUsername",
            "baseName": "auth_username",
            "type": "string"
        },
        {
            "name": "cloneAddr",
            "baseName": "clone_addr",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "issues",
            "baseName": "issues",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "boolean"
        },
        {
            "name": "lfs",
            "baseName": "lfs",
            "type": "boolean"
        },
        {
            "name": "lfsEndpoint",
            "baseName": "lfs_endpoint",
            "type": "string"
        },
        {
            "name": "milestones",
            "baseName": "milestones",
            "type": "boolean"
        },
        {
            "name": "mirror",
            "baseName": "mirror",
            "type": "boolean"
        },
        {
            "name": "mirrorInterval",
            "baseName": "mirror_interval",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "pullRequests",
            "baseName": "pull_requests",
            "type": "boolean"
        },
        {
            "name": "releases",
            "baseName": "releases",
            "type": "boolean"
        },
        {
            "name": "repoName",
            "baseName": "repo_name",
            "type": "string"
        },
        {
            "name": "service",
            "baseName": "service",
            "type": "GitServiceType"
        },
        {
            "name": "uid",
            "baseName": "uid",
            "type": "number"
        },
        {
            "name": "wiki",
            "baseName": "wiki",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MigrateRepoForm.attributeTypeMap;
    }
}

/**
* MigrateRepoOptions options for migrating repository's this is used to interact with api v1
*/
export class MigrateRepoOptions {
    'authPassword'?: string;
    'authToken'?: string;
    'authUsername'?: string;
    'cloneAddr': string;
    'description'?: string;
    'issues'?: boolean;
    'labels'?: boolean;
    'lfs'?: boolean;
    'lfsEndpoint'?: string;
    'milestones'?: boolean;
    'mirror'?: boolean;
    'mirrorInterval'?: string;
    '_private'?: boolean;
    'pullRequests'?: boolean;
    'releases'?: boolean;
    'repoName': string;
    /**
    * Name of User or Organisation who will own Repo after migration
    */
    'repoOwner'?: string;
    'service'?: MigrateRepoOptions.ServiceEnum;
    /**
    * deprecated (only for backwards compatibility)
    */
    'uid'?: number;
    'wiki'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authPassword",
            "baseName": "auth_password",
            "type": "string"
        },
        {
            "name": "authToken",
            "baseName": "auth_token",
            "type": "string"
        },
        {
            "name": "authUsername",
            "baseName": "auth_username",
            "type": "string"
        },
        {
            "name": "cloneAddr",
            "baseName": "clone_addr",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "issues",
            "baseName": "issues",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "boolean"
        },
        {
            "name": "lfs",
            "baseName": "lfs",
            "type": "boolean"
        },
        {
            "name": "lfsEndpoint",
            "baseName": "lfs_endpoint",
            "type": "string"
        },
        {
            "name": "milestones",
            "baseName": "milestones",
            "type": "boolean"
        },
        {
            "name": "mirror",
            "baseName": "mirror",
            "type": "boolean"
        },
        {
            "name": "mirrorInterval",
            "baseName": "mirror_interval",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "pullRequests",
            "baseName": "pull_requests",
            "type": "boolean"
        },
        {
            "name": "releases",
            "baseName": "releases",
            "type": "boolean"
        },
        {
            "name": "repoName",
            "baseName": "repo_name",
            "type": "string"
        },
        {
            "name": "repoOwner",
            "baseName": "repo_owner",
            "type": "string"
        },
        {
            "name": "service",
            "baseName": "service",
            "type": "MigrateRepoOptions.ServiceEnum"
        },
        {
            "name": "uid",
            "baseName": "uid",
            "type": "number"
        },
        {
            "name": "wiki",
            "baseName": "wiki",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return MigrateRepoOptions.attributeTypeMap;
    }
}

export namespace MigrateRepoOptions {
    export enum ServiceEnum {
        Git = <any> 'git',
        Github = <any> 'github',
        Gitea = <any> 'gitea',
        Gitlab = <any> 'gitlab'
    }
}
/**
* Milestone milestone is a collection of issues on one repository
*/
export class Milestone {
    'closedAt'?: Date;
    'closedIssues'?: number;
    'createdAt'?: Date;
    'description'?: string;
    'dueOn'?: Date;
    'id'?: number;
    'openIssues'?: number;
    'state'?: StateType;
    'title'?: string;
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "closedAt",
            "baseName": "closed_at",
            "type": "Date"
        },
        {
            "name": "closedIssues",
            "baseName": "closed_issues",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueOn",
            "baseName": "due_on",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "openIssues",
            "baseName": "open_issues",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "StateType"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Milestone.attributeTypeMap;
    }
}

/**
* NodeInfo contains standardized way of exposing metadata about a server running one of the distributed social networks
*/
export class NodeInfo {
    'metadata'?: any;
    'openRegistrations'?: boolean;
    'protocols'?: Array<string>;
    'services'?: NodeInfoServices;
    'software'?: NodeInfoSoftware;
    'usage'?: NodeInfoUsage;
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "any"
        },
        {
            "name": "openRegistrations",
            "baseName": "openRegistrations",
            "type": "boolean"
        },
        {
            "name": "protocols",
            "baseName": "protocols",
            "type": "Array<string>"
        },
        {
            "name": "services",
            "baseName": "services",
            "type": "NodeInfoServices"
        },
        {
            "name": "software",
            "baseName": "software",
            "type": "NodeInfoSoftware"
        },
        {
            "name": "usage",
            "baseName": "usage",
            "type": "NodeInfoUsage"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NodeInfo.attributeTypeMap;
    }
}

/**
* NodeInfoServices contains the third party sites this server can connect to via their application API
*/
export class NodeInfoServices {
    'inbound'?: Array<string>;
    'outbound'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "inbound",
            "baseName": "inbound",
            "type": "Array<string>"
        },
        {
            "name": "outbound",
            "baseName": "outbound",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NodeInfoServices.attributeTypeMap;
    }
}

/**
* NodeInfoSoftware contains Metadata about server software in use
*/
export class NodeInfoSoftware {
    'homepage'?: string;
    'name'?: string;
    'repository'?: string;
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "homepage",
            "baseName": "homepage",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "repository",
            "baseName": "repository",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NodeInfoSoftware.attributeTypeMap;
    }
}

/**
* NodeInfoUsage contains usage statistics for this server
*/
export class NodeInfoUsage {
    'localComments'?: number;
    'localPosts'?: number;
    'users'?: NodeInfoUsageUsers;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "localComments",
            "baseName": "localComments",
            "type": "number"
        },
        {
            "name": "localPosts",
            "baseName": "localPosts",
            "type": "number"
        },
        {
            "name": "users",
            "baseName": "users",
            "type": "NodeInfoUsageUsers"
        }    ];

    static getAttributeTypeMap() {
        return NodeInfoUsage.attributeTypeMap;
    }
}

/**
* NodeInfoUsageUsers contains statistics about the users of this server
*/
export class NodeInfoUsageUsers {
    'activeHalfyear'?: number;
    'activeMonth'?: number;
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "activeHalfyear",
            "baseName": "activeHalfyear",
            "type": "number"
        },
        {
            "name": "activeMonth",
            "baseName": "activeMonth",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return NodeInfoUsageUsers.attributeTypeMap;
    }
}

/**
* Note contains information related to a git note
*/
export class Note {
    'commit'?: Commit;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commit",
            "baseName": "commit",
            "type": "Commit"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Note.attributeTypeMap;
    }
}

/**
* NotificationCount number of unread notifications
*/
export class NotificationCount {
    '_new'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_new",
            "baseName": "new",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return NotificationCount.attributeTypeMap;
    }
}

/**
* NotificationSubject contains the notification subject (Issue/Pull/Commit)
*/
export class NotificationSubject {
    'htmlUrl'?: string;
    'latestCommentHtmlUrl'?: string;
    'latestCommentUrl'?: string;
    'state'?: StateType;
    'title'?: string;
    'type'?: NotifySubjectType;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "latestCommentHtmlUrl",
            "baseName": "latest_comment_html_url",
            "type": "string"
        },
        {
            "name": "latestCommentUrl",
            "baseName": "latest_comment_url",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "StateType"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "NotifySubjectType"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NotificationSubject.attributeTypeMap;
    }
}

/**
* NotificationThread expose Notification on API
*/
export class NotificationThread {
    'id'?: number;
    'pinned'?: boolean;
    'repository'?: Repository;
    'subject'?: NotificationSubject;
    'unread'?: boolean;
    'updatedAt'?: Date;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "pinned",
            "baseName": "pinned",
            "type": "boolean"
        },
        {
            "name": "repository",
            "baseName": "repository",
            "type": "Repository"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "NotificationSubject"
        },
        {
            "name": "unread",
            "baseName": "unread",
            "type": "boolean"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NotificationThread.attributeTypeMap;
    }
}

/**
* NotifySubjectType represent type of notification subject
*/
export class NotifySubjectType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return NotifySubjectType.attributeTypeMap;
    }
}

export class OAuth2Application {
    'clientId'?: string;
    'clientSecret'?: string;
    'created'?: Date;
    'id'?: number;
    'name'?: string;
    'redirectUris'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "clientSecret",
            "baseName": "client_secret",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "redirectUris",
            "baseName": "redirect_uris",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return OAuth2Application.attributeTypeMap;
    }
}

/**
* Organization represents an organization
*/
export class Organization {
    'avatarUrl'?: string;
    'description'?: string;
    'fullName'?: string;
    'id'?: number;
    'location'?: string;
    'repoAdminChangeTeamAccess'?: boolean;
    /**
    * DCS Customizations ***_/
    */
    'repoLanguages'?: Array<string>;
    'repoSubjects'?: Array<string>;
    'username'?: string;
    'visibility'?: string;
    'website'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "repoAdminChangeTeamAccess",
            "baseName": "repo_admin_change_team_access",
            "type": "boolean"
        },
        {
            "name": "repoLanguages",
            "baseName": "repo_languages",
            "type": "Array<string>"
        },
        {
            "name": "repoSubjects",
            "baseName": "repo_subjects",
            "type": "Array<string>"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "string"
        },
        {
            "name": "website",
            "baseName": "website",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Organization.attributeTypeMap;
    }
}

/**
* OrganizationPermissions list different users permissions on an organization
*/
export class OrganizationPermissions {
    'canCreateRepository'?: boolean;
    'canRead'?: boolean;
    'canWrite'?: boolean;
    'isAdmin'?: boolean;
    'isOwner'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "canCreateRepository",
            "baseName": "can_create_repository",
            "type": "boolean"
        },
        {
            "name": "canRead",
            "baseName": "can_read",
            "type": "boolean"
        },
        {
            "name": "canWrite",
            "baseName": "can_write",
            "type": "boolean"
        },
        {
            "name": "isAdmin",
            "baseName": "is_admin",
            "type": "boolean"
        },
        {
            "name": "isOwner",
            "baseName": "is_owner",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return OrganizationPermissions.attributeTypeMap;
    }
}

/**
* PRBranchInfo information about a branch
*/
export class PRBranchInfo {
    'label'?: string;
    'ref'?: string;
    'repo'?: Repository;
    'repoId'?: number;
    'sha'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "repo",
            "baseName": "repo",
            "type": "Repository"
        },
        {
            "name": "repoId",
            "baseName": "repo_id",
            "type": "number"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PRBranchInfo.attributeTypeMap;
    }
}

/**
* PayloadCommit represents a commit
*/
export class PayloadCommit {
    'added'?: Array<string>;
    'author'?: PayloadUser;
    'committer'?: PayloadUser;
    /**
    * sha1 hash of the commit
    */
    'id'?: string;
    'message'?: string;
    'modified'?: Array<string>;
    'removed'?: Array<string>;
    'timestamp'?: Date;
    'url'?: string;
    'verification'?: PayloadCommitVerification;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "added",
            "baseName": "added",
            "type": "Array<string>"
        },
        {
            "name": "author",
            "baseName": "author",
            "type": "PayloadUser"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "PayloadUser"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "modified",
            "baseName": "modified",
            "type": "Array<string>"
        },
        {
            "name": "removed",
            "baseName": "removed",
            "type": "Array<string>"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "Date"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "verification",
            "baseName": "verification",
            "type": "PayloadCommitVerification"
        }    ];

    static getAttributeTypeMap() {
        return PayloadCommit.attributeTypeMap;
    }
}

/**
* PayloadCommitVerification represents the GPG verification of a commit
*/
export class PayloadCommitVerification {
    'payload'?: string;
    'reason'?: string;
    'signature'?: string;
    'signer'?: PayloadUser;
    'verified'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "payload",
            "baseName": "payload",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "signature",
            "baseName": "signature",
            "type": "string"
        },
        {
            "name": "signer",
            "baseName": "signer",
            "type": "PayloadUser"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PayloadCommitVerification.attributeTypeMap;
    }
}

/**
* PayloadUser represents the author or committer of a commit
*/
export class PayloadUser {
    'email'?: string;
    /**
    * Full name of the commit author
    */
    'name'?: string;
    'username'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PayloadUser.attributeTypeMap;
    }
}

/**
* Permission represents a set of permissions
*/
export class Permission {
    'admin'?: boolean;
    'pull'?: boolean;
    'push'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "admin",
            "baseName": "admin",
            "type": "boolean"
        },
        {
            "name": "pull",
            "baseName": "pull",
            "type": "boolean"
        },
        {
            "name": "push",
            "baseName": "push",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Permission.attributeTypeMap;
    }
}

/**
* PublicKey publickey is a user key to push code to repository
*/
export class PublicKey {
    'createdAt'?: Date;
    'fingerprint'?: string;
    'id'?: number;
    'key'?: string;
    'keyType'?: string;
    'readOnly'?: boolean;
    'title'?: string;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "fingerprint",
            "baseName": "fingerprint",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "keyType",
            "baseName": "key_type",
            "type": "string"
        },
        {
            "name": "readOnly",
            "baseName": "read_only",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return PublicKey.attributeTypeMap;
    }
}

/**
* PullRequest represents a pull request
*/
export class PullRequest {
    'assignee'?: User;
    'assignees'?: Array<User>;
    'base'?: PRBranchInfo;
    'body'?: string;
    'closedAt'?: Date;
    'comments'?: number;
    'createdAt'?: Date;
    'diffUrl'?: string;
    'dueDate'?: Date;
    'head'?: PRBranchInfo;
    'htmlUrl'?: string;
    'id'?: number;
    'isLocked'?: boolean;
    'labels'?: Array<Label>;
    'mergeBase'?: string;
    'mergeCommitSha'?: string;
    'mergeable'?: boolean;
    'merged'?: boolean;
    'mergedAt'?: Date;
    'mergedBy'?: User;
    'milestone'?: Milestone;
    'number'?: number;
    'patchUrl'?: string;
    'state'?: StateType;
    'title'?: string;
    'updatedAt'?: Date;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignee",
            "baseName": "assignee",
            "type": "User"
        },
        {
            "name": "assignees",
            "baseName": "assignees",
            "type": "Array<User>"
        },
        {
            "name": "base",
            "baseName": "base",
            "type": "PRBranchInfo"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "closedAt",
            "baseName": "closed_at",
            "type": "Date"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "diffUrl",
            "baseName": "diff_url",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "due_date",
            "type": "Date"
        },
        {
            "name": "head",
            "baseName": "head",
            "type": "PRBranchInfo"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "isLocked",
            "baseName": "is_locked",
            "type": "boolean"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<Label>"
        },
        {
            "name": "mergeBase",
            "baseName": "merge_base",
            "type": "string"
        },
        {
            "name": "mergeCommitSha",
            "baseName": "merge_commit_sha",
            "type": "string"
        },
        {
            "name": "mergeable",
            "baseName": "mergeable",
            "type": "boolean"
        },
        {
            "name": "merged",
            "baseName": "merged",
            "type": "boolean"
        },
        {
            "name": "mergedAt",
            "baseName": "merged_at",
            "type": "Date"
        },
        {
            "name": "mergedBy",
            "baseName": "merged_by",
            "type": "User"
        },
        {
            "name": "milestone",
            "baseName": "milestone",
            "type": "Milestone"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "patchUrl",
            "baseName": "patch_url",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "StateType"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return PullRequest.attributeTypeMap;
    }
}

/**
* PullRequestMeta PR info if an issue is a PR
*/
export class PullRequestMeta {
    'merged'?: boolean;
    'mergedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merged",
            "baseName": "merged",
            "type": "boolean"
        },
        {
            "name": "mergedAt",
            "baseName": "merged_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PullRequestMeta.attributeTypeMap;
    }
}

/**
* PullReview represents a pull request review
*/
export class PullReview {
    'body'?: string;
    'commentsCount'?: number;
    'commitId'?: string;
    'dismissed'?: boolean;
    'htmlUrl'?: string;
    'id'?: number;
    'official'?: boolean;
    'pullRequestUrl'?: string;
    'stale'?: boolean;
    'state'?: ReviewStateType;
    'submittedAt'?: Date;
    'team'?: Team;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "commentsCount",
            "baseName": "comments_count",
            "type": "number"
        },
        {
            "name": "commitId",
            "baseName": "commit_id",
            "type": "string"
        },
        {
            "name": "dismissed",
            "baseName": "dismissed",
            "type": "boolean"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "official",
            "baseName": "official",
            "type": "boolean"
        },
        {
            "name": "pullRequestUrl",
            "baseName": "pull_request_url",
            "type": "string"
        },
        {
            "name": "stale",
            "baseName": "stale",
            "type": "boolean"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "ReviewStateType"
        },
        {
            "name": "submittedAt",
            "baseName": "submitted_at",
            "type": "Date"
        },
        {
            "name": "team",
            "baseName": "team",
            "type": "Team"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return PullReview.attributeTypeMap;
    }
}

/**
* PullReviewComment represents a comment on a pull request review
*/
export class PullReviewComment {
    'body'?: string;
    'commitId'?: string;
    'createdAt'?: Date;
    'diffHunk'?: string;
    'htmlUrl'?: string;
    'id'?: number;
    'originalCommitId'?: string;
    'originalPosition'?: number;
    'path'?: string;
    'position'?: number;
    'pullRequestReviewId'?: number;
    'pullRequestUrl'?: string;
    'resolver'?: User;
    'updatedAt'?: Date;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commit_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "diffHunk",
            "baseName": "diff_hunk",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "originalCommitId",
            "baseName": "original_commit_id",
            "type": "string"
        },
        {
            "name": "originalPosition",
            "baseName": "original_position",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "pullRequestReviewId",
            "baseName": "pull_request_review_id",
            "type": "number"
        },
        {
            "name": "pullRequestUrl",
            "baseName": "pull_request_url",
            "type": "string"
        },
        {
            "name": "resolver",
            "baseName": "resolver",
            "type": "User"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return PullReviewComment.attributeTypeMap;
    }
}

/**
* PullReviewRequestOptions are options to add or remove pull review requests
*/
export class PullReviewRequestOptions {
    'reviewers'?: Array<string>;
    'teamReviewers'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reviewers",
            "baseName": "reviewers",
            "type": "Array<string>"
        },
        {
            "name": "teamReviewers",
            "baseName": "team_reviewers",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PullReviewRequestOptions.attributeTypeMap;
    }
}

/**
* Reaction contain one reaction
*/
export class Reaction {
    'content'?: string;
    'createdAt'?: Date;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return Reaction.attributeTypeMap;
    }
}

export class Reference {
    'object'?: GitObject;
    'ref'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "object",
            "baseName": "object",
            "type": "GitObject"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Reference.attributeTypeMap;
    }
}

/**
* Release represents a repository release
*/
export class Release {
    'assets'?: Array<Attachment>;
    'author'?: User;
    'body'?: string;
    'createdAt'?: Date;
    'draft'?: boolean;
    'htmlUrl'?: string;
    'id'?: number;
    'name'?: string;
    'prerelease'?: boolean;
    'publishedAt'?: Date;
    'tagName'?: string;
    'tarballUrl'?: string;
    'targetCommitish'?: string;
    'url'?: string;
    'zipballUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assets",
            "baseName": "assets",
            "type": "Array<Attachment>"
        },
        {
            "name": "author",
            "baseName": "author",
            "type": "User"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "draft",
            "baseName": "draft",
            "type": "boolean"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "prerelease",
            "baseName": "prerelease",
            "type": "boolean"
        },
        {
            "name": "publishedAt",
            "baseName": "published_at",
            "type": "Date"
        },
        {
            "name": "tagName",
            "baseName": "tag_name",
            "type": "string"
        },
        {
            "name": "tarballUrl",
            "baseName": "tarball_url",
            "type": "string"
        },
        {
            "name": "targetCommitish",
            "baseName": "target_commitish",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "zipballUrl",
            "baseName": "zipball_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Release.attributeTypeMap;
    }
}

export class RepoCommit {
    'author'?: CommitUser;
    'committer'?: CommitUser;
    'message'?: string;
    'tree'?: CommitMeta;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "CommitUser"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "CommitUser"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "CommitMeta"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RepoCommit.attributeTypeMap;
    }
}

/**
* RepoTopicOptions a collection of repo topic names
*/
export class RepoTopicOptions {
    /**
    * list of topic names
    */
    'topics'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "topics",
            "baseName": "topics",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RepoTopicOptions.attributeTypeMap;
    }
}

/**
* RepoTransfer represents a pending repo transfer
*/
export class RepoTransfer {
    'doer'?: User;
    'recipient'?: User;
    'teams'?: Array<Team>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "doer",
            "baseName": "doer",
            "type": "User"
        },
        {
            "name": "recipient",
            "baseName": "recipient",
            "type": "User"
        },
        {
            "name": "teams",
            "baseName": "teams",
            "type": "Array<Team>"
        }    ];

    static getAttributeTypeMap() {
        return RepoTransfer.attributeTypeMap;
    }
}

/**
* Repository represents a repository
*/
export class Repository {
    'allowMergeCommits'?: boolean;
    'allowRebase'?: boolean;
    'allowRebaseExplicit'?: boolean;
    'allowSquashMerge'?: boolean;
    'archived'?: boolean;
    'avatarUrl'?: string;
    'books'?: Array<string>;
    'catalog'?: CatalogStages;
    'checkingLevel'?: string;
    'cloneUrl'?: string;
    'createdAt'?: Date;
    'defaultBranch'?: string;
    'defaultMergeStyle'?: string;
    'description'?: string;
    'empty'?: boolean;
    'externalTracker'?: ExternalTracker;
    'externalWiki'?: ExternalWiki;
    'fork'?: boolean;
    'forksCount'?: number;
    'fullName'?: string;
    'hasIssues'?: boolean;
    'hasProjects'?: boolean;
    'hasPullRequests'?: boolean;
    'hasWiki'?: boolean;
    'htmlUrl'?: string;
    'id'?: number;
    'ignoreWhitespaceConflicts'?: boolean;
    'internal'?: boolean;
    'internalTracker'?: InternalTracker;
    'language'?: string;
    'mirror'?: boolean;
    'mirrorInterval'?: string;
    'mirrorUpdated'?: Date;
    'name'?: string;
    'openIssuesCount'?: number;
    'openPrCounter'?: number;
    'originalUrl'?: string;
    'owner'?: User;
    'parent'?: Repository;
    'permissions'?: Permission;
    '_private'?: boolean;
    'releaseCounter'?: number;
    'repoTransfer'?: RepoTransfer;
    'size'?: number;
    'sshUrl'?: string;
    'starsCount'?: number;
    'subject'?: string;
    'template'?: boolean;
    'title'?: string;
    'updatedAt'?: Date;
    'watchersCount'?: number;
    'website'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "allowMergeCommits",
            "baseName": "allow_merge_commits",
            "type": "boolean"
        },
        {
            "name": "allowRebase",
            "baseName": "allow_rebase",
            "type": "boolean"
        },
        {
            "name": "allowRebaseExplicit",
            "baseName": "allow_rebase_explicit",
            "type": "boolean"
        },
        {
            "name": "allowSquashMerge",
            "baseName": "allow_squash_merge",
            "type": "boolean"
        },
        {
            "name": "archived",
            "baseName": "archived",
            "type": "boolean"
        },
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "books",
            "baseName": "books",
            "type": "Array<string>"
        },
        {
            "name": "catalog",
            "baseName": "catalog",
            "type": "CatalogStages"
        },
        {
            "name": "checkingLevel",
            "baseName": "checking_level",
            "type": "string"
        },
        {
            "name": "cloneUrl",
            "baseName": "clone_url",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "defaultBranch",
            "baseName": "default_branch",
            "type": "string"
        },
        {
            "name": "defaultMergeStyle",
            "baseName": "default_merge_style",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "empty",
            "baseName": "empty",
            "type": "boolean"
        },
        {
            "name": "externalTracker",
            "baseName": "external_tracker",
            "type": "ExternalTracker"
        },
        {
            "name": "externalWiki",
            "baseName": "external_wiki",
            "type": "ExternalWiki"
        },
        {
            "name": "fork",
            "baseName": "fork",
            "type": "boolean"
        },
        {
            "name": "forksCount",
            "baseName": "forks_count",
            "type": "number"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "hasIssues",
            "baseName": "has_issues",
            "type": "boolean"
        },
        {
            "name": "hasProjects",
            "baseName": "has_projects",
            "type": "boolean"
        },
        {
            "name": "hasPullRequests",
            "baseName": "has_pull_requests",
            "type": "boolean"
        },
        {
            "name": "hasWiki",
            "baseName": "has_wiki",
            "type": "boolean"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "ignoreWhitespaceConflicts",
            "baseName": "ignore_whitespace_conflicts",
            "type": "boolean"
        },
        {
            "name": "internal",
            "baseName": "internal",
            "type": "boolean"
        },
        {
            "name": "internalTracker",
            "baseName": "internal_tracker",
            "type": "InternalTracker"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "mirror",
            "baseName": "mirror",
            "type": "boolean"
        },
        {
            "name": "mirrorInterval",
            "baseName": "mirror_interval",
            "type": "string"
        },
        {
            "name": "mirrorUpdated",
            "baseName": "mirror_updated",
            "type": "Date"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "openIssuesCount",
            "baseName": "open_issues_count",
            "type": "number"
        },
        {
            "name": "openPrCounter",
            "baseName": "open_pr_counter",
            "type": "number"
        },
        {
            "name": "originalUrl",
            "baseName": "original_url",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "User"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "Repository"
        },
        {
            "name": "permissions",
            "baseName": "permissions",
            "type": "Permission"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "releaseCounter",
            "baseName": "release_counter",
            "type": "number"
        },
        {
            "name": "repoTransfer",
            "baseName": "repo_transfer",
            "type": "RepoTransfer"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "sshUrl",
            "baseName": "ssh_url",
            "type": "string"
        },
        {
            "name": "starsCount",
            "baseName": "stars_count",
            "type": "number"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "string"
        },
        {
            "name": "template",
            "baseName": "template",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "watchersCount",
            "baseName": "watchers_count",
            "type": "number"
        },
        {
            "name": "website",
            "baseName": "website",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Repository.attributeTypeMap;
    }
}

/**
* RepositoryMeta basic repository information
*/
export class RepositoryMeta {
    'fullName'?: string;
    'id'?: number;
    'name'?: string;
    'owner'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RepositoryMeta.attributeTypeMap;
    }
}

/**
* ReviewStateType review state type
*/
export class ReviewStateType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ReviewStateType.attributeTypeMap;
    }
}

/**
* SearchResults results of a successful search
*/
export class SearchResults {
    'data'?: Array<Repository>;
    'ok'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Repository>"
        },
        {
            "name": "ok",
            "baseName": "ok",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SearchResults.attributeTypeMap;
    }
}

/**
* ServerVersion wraps the version of the server
*/
export class ServerVersion {
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ServerVersion.attributeTypeMap;
    }
}

/**
* StateType issue state type
*/
export class StateType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return StateType.attributeTypeMap;
    }
}

/**
* StopWatch represent a running stopwatch
*/
export class StopWatch {
    'created'?: Date;
    'duration'?: string;
    'issueIndex'?: number;
    'issueTitle'?: string;
    'repoName'?: string;
    'repoOwnerName'?: string;
    'seconds'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "string"
        },
        {
            "name": "issueIndex",
            "baseName": "issue_index",
            "type": "number"
        },
        {
            "name": "issueTitle",
            "baseName": "issue_title",
            "type": "string"
        },
        {
            "name": "repoName",
            "baseName": "repo_name",
            "type": "string"
        },
        {
            "name": "repoOwnerName",
            "baseName": "repo_owner_name",
            "type": "string"
        },
        {
            "name": "seconds",
            "baseName": "seconds",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return StopWatch.attributeTypeMap;
    }
}

/**
* SubmitPullReviewOptions are options to submit a pending pull review
*/
export class SubmitPullReviewOptions {
    'body'?: string;
    'event'?: ReviewStateType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "ReviewStateType"
        }    ];

    static getAttributeTypeMap() {
        return SubmitPullReviewOptions.attributeTypeMap;
    }
}

/**
* Tag represents a repository tag
*/
export class Tag {
    'commit'?: CommitMeta;
    'id'?: string;
    'message'?: string;
    'name'?: string;
    'tarballUrl'?: string;
    'zipballUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commit",
            "baseName": "commit",
            "type": "CommitMeta"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tarballUrl",
            "baseName": "tarball_url",
            "type": "string"
        },
        {
            "name": "zipballUrl",
            "baseName": "zipball_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tag.attributeTypeMap;
    }
}

/**
* Team represents a team in an organization
*/
export class Team {
    'canCreateOrgRepo'?: boolean;
    'description'?: string;
    'id'?: number;
    'includesAllRepositories'?: boolean;
    'name'?: string;
    'organization'?: Organization;
    'permission'?: Team.PermissionEnum;
    'units'?: Array<string>;
    'unitsMap'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "canCreateOrgRepo",
            "baseName": "can_create_org_repo",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "includesAllRepositories",
            "baseName": "includes_all_repositories",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "Organization"
        },
        {
            "name": "permission",
            "baseName": "permission",
            "type": "Team.PermissionEnum"
        },
        {
            "name": "units",
            "baseName": "units",
            "type": "Array<string>"
        },
        {
            "name": "unitsMap",
            "baseName": "units_map",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return Team.attributeTypeMap;
    }
}

export namespace Team {
    export enum PermissionEnum {
        None = <any> 'none',
        Read = <any> 'read',
        Write = <any> 'write',
        Admin = <any> 'admin',
        Owner = <any> 'owner'
    }
}
/**
* TimeStamp defines a timestamp
*/
export class TimeStamp {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TimeStamp.attributeTypeMap;
    }
}

/**
* TimelineComment represents a timeline comment (comment of any type) on a commit or issue
*/
export class TimelineComment {
    'assignee'?: User;
    'assigneeTeam'?: Team;
    'body'?: string;
    'createdAt'?: Date;
    'dependentIssue'?: Issue;
    'htmlUrl'?: string;
    'id'?: number;
    'issueUrl'?: string;
    'label'?: Label;
    'milestone'?: Milestone;
    'newRef'?: string;
    'newTitle'?: string;
    'oldMilestone'?: Milestone;
    'oldProjectId'?: number;
    'oldRef'?: string;
    'oldTitle'?: string;
    'projectId'?: number;
    'pullRequestUrl'?: string;
    'refAction'?: string;
    'refComment'?: Comment;
    /**
    * commit SHA where issue/PR was referenced
    */
    'refCommitSha'?: string;
    'refIssue'?: Issue;
    /**
    * whether the assignees were removed or added
    */
    'removedAssignee'?: boolean;
    'resolveDoer'?: User;
    'reviewId'?: number;
    'trackedTime'?: TrackedTime;
    'type'?: string;
    'updatedAt'?: Date;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignee",
            "baseName": "assignee",
            "type": "User"
        },
        {
            "name": "assigneeTeam",
            "baseName": "assignee_team",
            "type": "Team"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "dependentIssue",
            "baseName": "dependent_issue",
            "type": "Issue"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "issueUrl",
            "baseName": "issue_url",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "Label"
        },
        {
            "name": "milestone",
            "baseName": "milestone",
            "type": "Milestone"
        },
        {
            "name": "newRef",
            "baseName": "new_ref",
            "type": "string"
        },
        {
            "name": "newTitle",
            "baseName": "new_title",
            "type": "string"
        },
        {
            "name": "oldMilestone",
            "baseName": "old_milestone",
            "type": "Milestone"
        },
        {
            "name": "oldProjectId",
            "baseName": "old_project_id",
            "type": "number"
        },
        {
            "name": "oldRef",
            "baseName": "old_ref",
            "type": "string"
        },
        {
            "name": "oldTitle",
            "baseName": "old_title",
            "type": "string"
        },
        {
            "name": "projectId",
            "baseName": "project_id",
            "type": "number"
        },
        {
            "name": "pullRequestUrl",
            "baseName": "pull_request_url",
            "type": "string"
        },
        {
            "name": "refAction",
            "baseName": "ref_action",
            "type": "string"
        },
        {
            "name": "refComment",
            "baseName": "ref_comment",
            "type": "Comment"
        },
        {
            "name": "refCommitSha",
            "baseName": "ref_commit_sha",
            "type": "string"
        },
        {
            "name": "refIssue",
            "baseName": "ref_issue",
            "type": "Issue"
        },
        {
            "name": "removedAssignee",
            "baseName": "removed_assignee",
            "type": "boolean"
        },
        {
            "name": "resolveDoer",
            "baseName": "resolve_doer",
            "type": "User"
        },
        {
            "name": "reviewId",
            "baseName": "review_id",
            "type": "number"
        },
        {
            "name": "trackedTime",
            "baseName": "tracked_time",
            "type": "TrackedTime"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return TimelineComment.attributeTypeMap;
    }
}

/**
* TopicName a list of repo topic names
*/
export class TopicName {
    'topics'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "topics",
            "baseName": "topics",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return TopicName.attributeTypeMap;
    }
}

/**
* TopicResponse for returning topics
*/
export class TopicResponse {
    'created'?: Date;
    'id'?: number;
    'repoCount'?: number;
    'topicName'?: string;
    'updated'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "repoCount",
            "baseName": "repo_count",
            "type": "number"
        },
        {
            "name": "topicName",
            "baseName": "topic_name",
            "type": "string"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return TopicResponse.attributeTypeMap;
    }
}

/**
* TrackedTime worked time for an issue / pr
*/
export class TrackedTime {
    'created'?: Date;
    'id'?: number;
    'issue'?: Issue;
    /**
    * deprecated (only for backwards compatibility)
    */
    'issueId'?: number;
    /**
    * Time in seconds
    */
    'time'?: number;
    /**
    * deprecated (only for backwards compatibility)
    */
    'userId'?: number;
    'userName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "issue",
            "baseName": "issue",
            "type": "Issue"
        },
        {
            "name": "issueId",
            "baseName": "issue_id",
            "type": "number"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        },
        {
            "name": "userName",
            "baseName": "user_name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TrackedTime.attributeTypeMap;
    }
}

/**
* TransferRepoOption options when transfer a repository's ownership
*/
export class TransferRepoOption {
    'newOwner': string;
    /**
    * ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
    */
    'teamIds'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "newOwner",
            "baseName": "new_owner",
            "type": "string"
        },
        {
            "name": "teamIds",
            "baseName": "team_ids",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return TransferRepoOption.attributeTypeMap;
    }
}

/**
* UpdateFileOptions options for updating files Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
*/
export class UpdateFileOptions {
    'author'?: Identity;
    /**
    * branch (optional) to base this file from. if not given, the default branch is used
    */
    'branch'?: string;
    'committer'?: Identity;
    /**
    * content must be base64 encoded
    */
    'content': string;
    'dates'?: CommitDateOptions;
    /**
    * from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL
    */
    'fromPath'?: string;
    /**
    * message (optional) for the commit of this file. if not supplied, a default message will be used
    */
    'message'?: string;
    /**
    * new_branch (optional) will make a new branch from `branch` before creating the file
    */
    'newBranch'?: string;
    /**
    * sha is the SHA for the file that already exists
    */
    'sha': string;
    /**
    * Add a Signed-off-by trailer by the committer at the end of the commit log message.
    */
    'signoff'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "Identity"
        },
        {
            "name": "branch",
            "baseName": "branch",
            "type": "string"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "Identity"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "dates",
            "baseName": "dates",
            "type": "CommitDateOptions"
        },
        {
            "name": "fromPath",
            "baseName": "from_path",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "newBranch",
            "baseName": "new_branch",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "signoff",
            "baseName": "signoff",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UpdateFileOptions.attributeTypeMap;
    }
}

/**
* User represents a user
*/
export class User {
    /**
    * Is user active
    */
    'active'?: boolean;
    /**
    * URL to the user's avatar
    */
    'avatarUrl'?: string;
    'created'?: Date;
    /**
    * the user's description
    */
    'description'?: string;
    'email'?: string;
    /**
    * user counts
    */
    'followersCount'?: number;
    'followingCount'?: number;
    /**
    * the user's full name
    */
    'fullName'?: string;
    /**
    * the user's id
    */
    'id'?: number;
    /**
    * Is the user an administrator
    */
    'isAdmin'?: boolean;
    /**
    * User locale
    */
    'language'?: string;
    'lastLogin'?: Date;
    /**
    * the user's location
    */
    'location'?: string;
    /**
    * the user's username
    */
    'login'?: string;
    /**
    * Is user login prohibited
    */
    'prohibitLogin'?: boolean;
    /**
    * DCS Customizations ***_/ Repo languages
    */
    'repoLanguages'?: Array<string>;
    /**
    * Repo subjects
    */
    'repoSubjects'?: Array<string>;
    /**
    * END DCS Customizations ***_/ Is user restricted
    */
    'restricted'?: boolean;
    'starredReposCount'?: number;
    /**
    * User visibility level option: public, limited, private
    */
    'visibility'?: string;
    /**
    * the user's website
    */
    'website'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "created",
            "baseName": "created",
            "type": "Date"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "followersCount",
            "baseName": "followers_count",
            "type": "number"
        },
        {
            "name": "followingCount",
            "baseName": "following_count",
            "type": "number"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "isAdmin",
            "baseName": "is_admin",
            "type": "boolean"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "lastLogin",
            "baseName": "last_login",
            "type": "Date"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "login",
            "baseName": "login",
            "type": "string"
        },
        {
            "name": "prohibitLogin",
            "baseName": "prohibit_login",
            "type": "boolean"
        },
        {
            "name": "repoLanguages",
            "baseName": "repo_languages",
            "type": "Array<string>"
        },
        {
            "name": "repoSubjects",
            "baseName": "repo_subjects",
            "type": "Array<string>"
        },
        {
            "name": "restricted",
            "baseName": "restricted",
            "type": "boolean"
        },
        {
            "name": "starredReposCount",
            "baseName": "starred_repos_count",
            "type": "number"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "string"
        },
        {
            "name": "website",
            "baseName": "website",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

/**
* UserHeatmapData represents the data needed to create a heatmap
*/
export class UserHeatmapData {
    'contributions'?: number;
    'timestamp'?: TimeStamp;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contributions",
            "baseName": "contributions",
            "type": "number"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "TimeStamp"
        }    ];

    static getAttributeTypeMap() {
        return UserHeatmapData.attributeTypeMap;
    }
}

/**
* UserSettings represents user settings
*/
export class UserSettings {
    'description'?: string;
    'diffViewStyle'?: string;
    'fullName'?: string;
    'hideActivity'?: boolean;
    /**
    * Privacy
    */
    'hideEmail'?: boolean;
    'language'?: string;
    'location'?: string;
    'theme'?: string;
    'website'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "diffViewStyle",
            "baseName": "diff_view_style",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "hideActivity",
            "baseName": "hide_activity",
            "type": "boolean"
        },
        {
            "name": "hideEmail",
            "baseName": "hide_email",
            "type": "boolean"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "theme",
            "baseName": "theme",
            "type": "string"
        },
        {
            "name": "website",
            "baseName": "website",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserSettings.attributeTypeMap;
    }
}

/**
* UserSettingsOptions represents options to change user settings
*/
export class UserSettingsOptions {
    'description'?: string;
    'diffViewStyle'?: string;
    'fullName'?: string;
    'hideActivity'?: boolean;
    /**
    * Privacy
    */
    'hideEmail'?: boolean;
    'language'?: string;
    'location'?: string;
    'theme'?: string;
    'website'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "diffViewStyle",
            "baseName": "diff_view_style",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "hideActivity",
            "baseName": "hide_activity",
            "type": "boolean"
        },
        {
            "name": "hideEmail",
            "baseName": "hide_email",
            "type": "boolean"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "theme",
            "baseName": "theme",
            "type": "string"
        },
        {
            "name": "website",
            "baseName": "website",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserSettingsOptions.attributeTypeMap;
    }
}

/**
* WatchInfo represents an API watch status of one repository
*/
export class WatchInfo {
    'createdAt'?: Date;
    'ignored'?: boolean;
    'reason'?: any;
    'repositoryUrl'?: string;
    'subscribed'?: boolean;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "ignored",
            "baseName": "ignored",
            "type": "boolean"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "any"
        },
        {
            "name": "repositoryUrl",
            "baseName": "repository_url",
            "type": "string"
        },
        {
            "name": "subscribed",
            "baseName": "subscribed",
            "type": "boolean"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WatchInfo.attributeTypeMap;
    }
}

/**
* WikiCommit page commit/revision
*/
export class WikiCommit {
    'author'?: CommitUser;
    'commiter'?: CommitUser;
    'message'?: string;
    'sha'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "CommitUser"
        },
        {
            "name": "commiter",
            "baseName": "commiter",
            "type": "CommitUser"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WikiCommit.attributeTypeMap;
    }
}

/**
* WikiCommitList commit/revision list
*/
export class WikiCommitList {
    'commits'?: Array<WikiCommit>;
    'count'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commits",
            "baseName": "commits",
            "type": "Array<WikiCommit>"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return WikiCommitList.attributeTypeMap;
    }
}

/**
* WikiPage a wiki page
*/
export class WikiPage {
    'commitCount'?: number;
    /**
    * Page content, base64 encoded
    */
    'contentBase64'?: string;
    'footer'?: string;
    'htmlUrl'?: string;
    'lastCommit'?: WikiCommit;
    'sidebar'?: string;
    'subUrl'?: string;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commitCount",
            "baseName": "commit_count",
            "type": "number"
        },
        {
            "name": "contentBase64",
            "baseName": "content_base64",
            "type": "string"
        },
        {
            "name": "footer",
            "baseName": "footer",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "lastCommit",
            "baseName": "last_commit",
            "type": "WikiCommit"
        },
        {
            "name": "sidebar",
            "baseName": "sidebar",
            "type": "string"
        },
        {
            "name": "subUrl",
            "baseName": "sub_url",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WikiPage.attributeTypeMap;
    }
}

/**
* WikiPageMetaData wiki page meta information
*/
export class WikiPageMetaData {
    'htmlUrl'?: string;
    'lastCommit'?: WikiCommit;
    'subUrl'?: string;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "lastCommit",
            "baseName": "last_commit",
            "type": "WikiCommit"
        },
        {
            "name": "subUrl",
            "baseName": "sub_url",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WikiPageMetaData.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "CreateHookOption.TypeEnum": CreateHookOption.TypeEnum,
        "CreateMilestoneOption.StateEnum": CreateMilestoneOption.StateEnum,
        "CreateOrgOption.VisibilityEnum": CreateOrgOption.VisibilityEnum,
        "CreateRepoOption.TrustModelEnum": CreateRepoOption.TrustModelEnum,
        "CreateTeamOption.PermissionEnum": CreateTeamOption.PermissionEnum,
        "EditOrgOption.VisibilityEnum": EditOrgOption.VisibilityEnum,
        "EditTeamOption.PermissionEnum": EditTeamOption.PermissionEnum,
        "MergePullRequestOption.DoEnum": MergePullRequestOption.DoEnum,
        "MigrateRepoOptions.ServiceEnum": MigrateRepoOptions.ServiceEnum,
        "Team.PermissionEnum": Team.PermissionEnum,
}

let typeMap: {[index: string]: any} = {
    "APIError": APIError,
    "AccessToken": AccessToken,
    "AddCollaboratorOption": AddCollaboratorOption,
    "AddTimeOption": AddTimeOption,
    "AnnotatedTag": AnnotatedTag,
    "AnnotatedTagObject": AnnotatedTagObject,
    "Attachment": Attachment,
    "Branch": Branch,
    "BranchProtection": BranchProtection,
    "CatalogStage": CatalogStage,
    "CatalogStages": CatalogStages,
    "CombinedStatus": CombinedStatus,
    "Comment": Comment,
    "Commit": Commit,
    "CommitAffectedFiles": CommitAffectedFiles,
    "CommitDateOptions": CommitDateOptions,
    "CommitMeta": CommitMeta,
    "CommitStatus": CommitStatus,
    "CommitStatusState": CommitStatusState,
    "CommitUser": CommitUser,
    "ContentsResponse": ContentsResponse,
    "CreateAccessTokenOption": CreateAccessTokenOption,
    "CreateBranchProtectionOption": CreateBranchProtectionOption,
    "CreateBranchRepoOption": CreateBranchRepoOption,
    "CreateEmailOption": CreateEmailOption,
    "CreateFileOptions": CreateFileOptions,
    "CreateForkOption": CreateForkOption,
    "CreateGPGKeyOption": CreateGPGKeyOption,
    "CreateHookOption": CreateHookOption,
    "CreateHookOptionConfig": CreateHookOptionConfig,
    "CreateIssueCommentOption": CreateIssueCommentOption,
    "CreateIssueOption": CreateIssueOption,
    "CreateKeyOption": CreateKeyOption,
    "CreateLabelOption": CreateLabelOption,
    "CreateMilestoneOption": CreateMilestoneOption,
    "CreateOAuth2ApplicationOptions": CreateOAuth2ApplicationOptions,
    "CreateOrgOption": CreateOrgOption,
    "CreatePullRequestOption": CreatePullRequestOption,
    "CreatePullReviewComment": CreatePullReviewComment,
    "CreatePullReviewOptions": CreatePullReviewOptions,
    "CreateReleaseOption": CreateReleaseOption,
    "CreateRepoOption": CreateRepoOption,
    "CreateStatusOption": CreateStatusOption,
    "CreateTagOption": CreateTagOption,
    "CreateTeamOption": CreateTeamOption,
    "CreateUserOption": CreateUserOption,
    "CreateWikiPageOptions": CreateWikiPageOptions,
    "Cron": Cron,
    "DeleteEmailOption": DeleteEmailOption,
    "DeleteFileOptions": DeleteFileOptions,
    "DeployKey": DeployKey,
    "DismissPullReviewOptions": DismissPullReviewOptions,
    "EditAttachmentOptions": EditAttachmentOptions,
    "EditBranchProtectionOption": EditBranchProtectionOption,
    "EditDeadlineOption": EditDeadlineOption,
    "EditGitHookOption": EditGitHookOption,
    "EditHookOption": EditHookOption,
    "EditIssueCommentOption": EditIssueCommentOption,
    "EditIssueOption": EditIssueOption,
    "EditLabelOption": EditLabelOption,
    "EditMilestoneOption": EditMilestoneOption,
    "EditOrgOption": EditOrgOption,
    "EditPullRequestOption": EditPullRequestOption,
    "EditReactionOption": EditReactionOption,
    "EditReleaseOption": EditReleaseOption,
    "EditRepoOption": EditRepoOption,
    "EditTeamOption": EditTeamOption,
    "EditUserOption": EditUserOption,
    "Email": Email,
    "ExternalTracker": ExternalTracker,
    "ExternalWiki": ExternalWiki,
    "FileCommitResponse": FileCommitResponse,
    "FileDeleteResponse": FileDeleteResponse,
    "FileLinksResponse": FileLinksResponse,
    "FileResponse": FileResponse,
    "GPGKey": GPGKey,
    "GPGKeyEmail": GPGKeyEmail,
    "GeneralAPISettings": GeneralAPISettings,
    "GeneralAttachmentSettings": GeneralAttachmentSettings,
    "GeneralRepoSettings": GeneralRepoSettings,
    "GeneralUISettings": GeneralUISettings,
    "GenerateRepoOption": GenerateRepoOption,
    "GitBlobResponse": GitBlobResponse,
    "GitEntry": GitEntry,
    "GitHook": GitHook,
    "GitObject": GitObject,
    "GitServiceType": GitServiceType,
    "GitTreeResponse": GitTreeResponse,
    "Hook": Hook,
    "Identity": Identity,
    "InternalTracker": InternalTracker,
    "Issue": Issue,
    "IssueDeadline": IssueDeadline,
    "IssueLabelsOption": IssueLabelsOption,
    "IssueTemplate": IssueTemplate,
    "Label": Label,
    "MarkdownOption": MarkdownOption,
    "MergePullRequestOption": MergePullRequestOption,
    "MigrateRepoForm": MigrateRepoForm,
    "MigrateRepoOptions": MigrateRepoOptions,
    "Milestone": Milestone,
    "NodeInfo": NodeInfo,
    "NodeInfoServices": NodeInfoServices,
    "NodeInfoSoftware": NodeInfoSoftware,
    "NodeInfoUsage": NodeInfoUsage,
    "NodeInfoUsageUsers": NodeInfoUsageUsers,
    "Note": Note,
    "NotificationCount": NotificationCount,
    "NotificationSubject": NotificationSubject,
    "NotificationThread": NotificationThread,
    "NotifySubjectType": NotifySubjectType,
    "OAuth2Application": OAuth2Application,
    "Organization": Organization,
    "OrganizationPermissions": OrganizationPermissions,
    "PRBranchInfo": PRBranchInfo,
    "PayloadCommit": PayloadCommit,
    "PayloadCommitVerification": PayloadCommitVerification,
    "PayloadUser": PayloadUser,
    "Permission": Permission,
    "PublicKey": PublicKey,
    "PullRequest": PullRequest,
    "PullRequestMeta": PullRequestMeta,
    "PullReview": PullReview,
    "PullReviewComment": PullReviewComment,
    "PullReviewRequestOptions": PullReviewRequestOptions,
    "Reaction": Reaction,
    "Reference": Reference,
    "Release": Release,
    "RepoCommit": RepoCommit,
    "RepoTopicOptions": RepoTopicOptions,
    "RepoTransfer": RepoTransfer,
    "Repository": Repository,
    "RepositoryMeta": RepositoryMeta,
    "ReviewStateType": ReviewStateType,
    "SearchResults": SearchResults,
    "ServerVersion": ServerVersion,
    "StateType": StateType,
    "StopWatch": StopWatch,
    "SubmitPullReviewOptions": SubmitPullReviewOptions,
    "Tag": Tag,
    "Team": Team,
    "TimeStamp": TimeStamp,
    "TimelineComment": TimelineComment,
    "TopicName": TopicName,
    "TopicResponse": TopicResponse,
    "TrackedTime": TrackedTime,
    "TransferRepoOption": TransferRepoOption,
    "UpdateFileOptions": UpdateFileOptions,
    "User": User,
    "UserHeatmapData": UserHeatmapData,
    "UserSettings": UserSettings,
    "UserSettingsOptions": UserSettingsOptions,
    "WatchInfo": WatchInfo,
    "WikiCommit": WikiCommit,
    "WikiCommitList": WikiCommitList,
    "WikiPage": WikiPage,
    "WikiPageMetaData": WikiPageMetaData,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AdminApiApiKeys {
    AccessToken,
    AuthorizationHeaderToken,
    SudoHeader,
    SudoParam,
    TOTPHeader,
    Token,
}

export class AdminApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AccessToken': new ApiKeyAuth('query', 'access_token'),
        'AuthorizationHeaderToken': new ApiKeyAuth('header', 'Authorization'),
        'BasicAuth': new HttpBasicAuth(),
        'SudoHeader': new ApiKeyAuth('header', 'Sudo'),
        'SudoParam': new ApiKeyAuth('query', 'sudo'),
        'TOTPHeader': new ApiKeyAuth('header', 'X-GITEA-OTP'),
        'Token': new ApiKeyAuth('query', 'token'),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AdminApiApiKeys, value: string) {
        (this.authentications as any)[AdminApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.BasicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * 
     * @summary Adopt unadopted files as a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public adminAdoptRepository (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/admin/unadopted/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling adminAdoptRepository.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling adminAdoptRepository.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create an organization
     * @param username username of the user that will own the created organization
     * @param organization 
     * @param {*} [options] Override http request options.
     */
    public adminCreateOrg (username: string, organization: CreateOrgOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Organization;  }> {
        const localVarPath = this.basePath + '/admin/users/{username}/orgs'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling adminCreateOrg.');
        }

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling adminCreateOrg.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(organization, "CreateOrgOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Organization;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Organization");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a public key on behalf of a user
     * @param username username of the user
     * @param key 
     * @param {*} [options] Override http request options.
     */
    public adminCreatePublicKey (username: string, key?: CreateKeyOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PublicKey;  }> {
        const localVarPath = this.basePath + '/admin/users/{username}/keys'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling adminCreatePublicKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(key, "CreateKeyOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PublicKey;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PublicKey");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a repository on behalf of a user
     * @param username username of the user. This user will own the created repository
     * @param repository 
     * @param {*} [options] Override http request options.
     */
    public adminCreateRepo (username: string, repository: CreateRepoOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/admin/users/{username}/repos'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling adminCreateRepo.');
        }

        // verify required parameter 'repository' is not null or undefined
        if (repository === null || repository === undefined) {
            throw new Error('Required parameter repository was null or undefined when calling adminCreateRepo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(repository, "CreateRepoOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a user
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public adminCreateUser (body?: CreateUserOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: User;  }> {
        const localVarPath = this.basePath + '/admin/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateUserOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List cron tasks
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public adminCronList (page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Cron>;  }> {
        const localVarPath = this.basePath + '/admin/cron';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Cron>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Cron>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Run cron task
     * @param task task to run
     * @param {*} [options] Override http request options.
     */
    public adminCronRun (task: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/admin/cron/{task}'
            .replace('{' + 'task' + '}', encodeURIComponent(String(task)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'task' is not null or undefined
        if (task === null || task === undefined) {
            throw new Error('Required parameter task was null or undefined when calling adminCronRun.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete unadopted files
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public adminDeleteUnadoptedRepository (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/admin/unadopted/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling adminDeleteUnadoptedRepository.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling adminDeleteUnadoptedRepository.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a user
     * @param username username of user to delete
     * @param {*} [options] Override http request options.
     */
    public adminDeleteUser (username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/admin/users/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling adminDeleteUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a user's public key
     * @param username username of user
     * @param id id of the key to delete
     * @param {*} [options] Override http request options.
     */
    public adminDeleteUserPublicKey (username: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/admin/users/{username}/keys/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling adminDeleteUserPublicKey.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling adminDeleteUserPublicKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit an existing user
     * @param username username of user to edit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public adminEditUser (username: string, body?: EditUserOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: User;  }> {
        const localVarPath = this.basePath + '/admin/users/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling adminEditUser.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditUserOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all organizations
     * @param lang If the org has one or more repos with the given language(s), the org will be in the results. Multiple lang&#39;s are ORed.
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public adminGetAllOrgs (lang?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Organization>;  }> {
        const localVarPath = this.basePath + '/admin/orgs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (lang !== undefined) {
            localVarQueryParameters['lang'] = ObjectSerializer.serialize(lang, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Organization>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Organization>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all users
     * @param lang If the user has one or more repos with the given language(s), the org will be in the results. Multiple lang&#39;s are ORed.
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public adminGetAllUsers (lang?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/admin/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (lang !== undefined) {
            localVarQueryParameters['lang'] = ObjectSerializer.serialize(lang, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List unadopted repositories
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param pattern pattern of repositories to search for
     * @param {*} [options] Override http request options.
     */
    public adminUnadoptedList (page?: number, limit?: number, pattern?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/admin/unadopted';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (pattern !== undefined) {
            localVarQueryParameters['pattern'] = ObjectSerializer.serialize(pattern, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum IssueApiApiKeys {
    AccessToken,
    AuthorizationHeaderToken,
    SudoHeader,
    SudoParam,
    TOTPHeader,
    Token,
}

export class IssueApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AccessToken': new ApiKeyAuth('query', 'access_token'),
        'AuthorizationHeaderToken': new ApiKeyAuth('header', 'Authorization'),
        'BasicAuth': new HttpBasicAuth(),
        'SudoHeader': new ApiKeyAuth('header', 'Sudo'),
        'SudoParam': new ApiKeyAuth('query', 'sudo'),
        'TOTPHeader': new ApiKeyAuth('header', 'X-GITEA-OTP'),
        'Token': new ApiKeyAuth('query', 'token'),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: IssueApiApiKeys, value: string) {
        (this.authentications as any)[IssueApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.BasicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * 
     * @summary Add a label to an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueAddLabel (owner: string, repo: string, index: number, body?: IssueLabelsOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Label>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueAddLabel.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueAddLabel.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueAddLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "IssueLabelsOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Label>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Label>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Subscribe user to issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param user user to subscribe
     * @param {*} [options] Override http request options.
     */
    public issueAddSubscription (owner: string, repo: string, index: number, user: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueAddSubscription.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueAddSubscription.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueAddSubscription.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling issueAddSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add tracked time to a issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueAddTime (owner: string, repo: string, index: number, body?: AddTimeOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TrackedTime;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/times'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueAddTime.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueAddTime.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueAddTime.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AddTimeOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TrackedTime;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TrackedTime");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Check if user is subscribed to an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param {*} [options] Override http request options.
     */
    public issueCheckSubscription (owner: string, repo: string, index: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WatchInfo;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/subscriptions/check'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueCheckSubscription.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueCheckSubscription.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueCheckSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WatchInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WatchInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove all labels from an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param {*} [options] Override http request options.
     */
    public issueClearLabels (owner: string, repo: string, index: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueClearLabels.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueClearLabels.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueClearLabels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a comment to an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCreateComment (owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Comment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueCreateComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueCreateComment.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueCreateComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateIssueCommentOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Comment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Comment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCreateIssue (owner: string, repo: string, body?: CreateIssueOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Issue;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueCreateIssue.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueCreateIssue.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateIssueOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Issue;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Issue");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a label
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCreateLabel (owner: string, repo: string, body?: CreateLabelOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueCreateLabel.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueCreateLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateLabelOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Label");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a milestone
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueCreateMilestone (owner: string, repo: string, body?: CreateMilestoneOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Milestone;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueCreateMilestone.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueCreateMilestone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateMilestoneOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Milestone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Milestone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a comment
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of comment to delete
     * @param {*} [options] Override http request options.
     */
    public issueDeleteComment (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueDeleteComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueDeleteComment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueDeleteComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a comment
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index this parameter is ignored
     * @param id id of comment to delete
     * @param {*} [options] Override http request options.
     */
    public issueDeleteCommentDeprecated (owner: string, repo: string, index: number, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/comments/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueDeleteCommentDeprecated.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueDeleteCommentDeprecated.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueDeleteCommentDeprecated.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueDeleteCommentDeprecated.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a reaction from a comment of an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the comment to edit
     * @param content 
     * @param {*} [options] Override http request options.
     */
    public issueDeleteCommentReaction (owner: string, repo: string, id: number, content?: EditReactionOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{id}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueDeleteCommentReaction.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueDeleteCommentReaction.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueDeleteCommentReaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(content, "EditReactionOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a reaction from an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param content 
     * @param {*} [options] Override http request options.
     */
    public issueDeleteIssueReaction (owner: string, repo: string, index: number, content?: EditReactionOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueDeleteIssueReaction.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueDeleteIssueReaction.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueDeleteIssueReaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(content, "EditReactionOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a label
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the label to delete
     * @param {*} [options] Override http request options.
     */
    public issueDeleteLabel (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueDeleteLabel.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueDeleteLabel.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueDeleteLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a milestone
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id the milestone to delete, identified by ID and if not available by name
     * @param {*} [options] Override http request options.
     */
    public issueDeleteMilestone (owner: string, repo: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueDeleteMilestone.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueDeleteMilestone.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueDeleteMilestone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an issue's existing stopwatch.
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue to stop the stopwatch on
     * @param {*} [options] Override http request options.
     */
    public issueDeleteStopWatch (owner: string, repo: string, index: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/stopwatch/delete'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueDeleteStopWatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueDeleteStopWatch.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueDeleteStopWatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unsubscribe user from issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param user user witch unsubscribe
     * @param {*} [options] Override http request options.
     */
    public issueDeleteSubscription (owner: string, repo: string, index: number, user: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueDeleteSubscription.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueDeleteSubscription.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueDeleteSubscription.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling issueDeleteSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete specific tracked time
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param id id of time to delete
     * @param {*} [options] Override http request options.
     */
    public issueDeleteTime (owner: string, repo: string, index: number, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/times/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueDeleteTime.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueDeleteTime.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueDeleteTime.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueDeleteTime.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a comment
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the comment to edit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueEditComment (owner: string, repo: string, id: number, body?: EditIssueCommentOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Comment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueEditComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueEditComment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueEditComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditIssueCommentOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Comment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Comment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a comment
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index this parameter is ignored
     * @param id id of the comment to edit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueEditCommentDeprecated (owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Comment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/comments/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueEditCommentDeprecated.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueEditCommentDeprecated.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueEditCommentDeprecated.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueEditCommentDeprecated.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditIssueCommentOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Comment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Comment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue to edit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueEditIssue (owner: string, repo: string, index: number, body?: EditIssueOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Issue;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueEditIssue.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueEditIssue.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueEditIssue.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditIssueOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Issue;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Issue");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue to create or update a deadline on
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueEditIssueDeadline (owner: string, repo: string, index: number, body?: EditDeadlineOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssueDeadline;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/deadline'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueEditIssueDeadline.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueEditIssueDeadline.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueEditIssueDeadline.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditDeadlineOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssueDeadline;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssueDeadline");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a label
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the label to edit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueEditLabel (owner: string, repo: string, id: number, body?: EditLabelOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueEditLabel.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueEditLabel.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueEditLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditLabelOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Label");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a milestone
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id the milestone to edit, identified by ID and if not available by name
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueEditMilestone (owner: string, repo: string, id: string, body?: EditMilestoneOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Milestone;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueEditMilestone.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueEditMilestone.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueEditMilestone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditMilestoneOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Milestone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Milestone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a comment
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the comment
     * @param {*} [options] Override http request options.
     */
    public issueGetComment (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Comment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueGetComment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueGetComment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueGetComment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Comment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Comment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of reactions from a comment of an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the comment to edit
     * @param {*} [options] Override http request options.
     */
    public issueGetCommentReactions (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{id}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueGetCommentReactions.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueGetCommentReactions.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueGetCommentReactions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Reaction>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all comments on an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param since if provided, only comments updated since the specified time are returned.
     * @param before if provided, only comments updated before the provided time are returned.
     * @param {*} [options] Override http request options.
     */
    public issueGetComments (owner: string, repo: string, index: number, since?: Date, before?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Comment>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueGetComments.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueGetComments.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueGetComments.');
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Comment>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Comment>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all comments and events on an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param since if provided, only comments updated since the specified time are returned.
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param before if provided, only comments updated before the provided time are returned.
     * @param {*} [options] Override http request options.
     */
    public issueGetCommentsAndTimeline (owner: string, repo: string, index: number, since?: Date, page?: number, limit?: number, before?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TimelineComment>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/timeline'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueGetCommentsAndTimeline.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueGetCommentsAndTimeline.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueGetCommentsAndTimeline.');
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TimelineComment>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TimelineComment>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue to get
     * @param {*} [options] Override http request options.
     */
    public issueGetIssue (owner: string, repo: string, index: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Issue;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueGetIssue.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueGetIssue.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueGetIssue.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Issue;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Issue");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list reactions of an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public issueGetIssueReactions (owner: string, repo: string, index: number, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueGetIssueReactions.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueGetIssueReactions.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueGetIssueReactions.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Reaction>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Reaction>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single label
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the label to get
     * @param {*} [options] Override http request options.
     */
    public issueGetLabel (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueGetLabel.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueGetLabel.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueGetLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Label");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an issue's labels
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param {*} [options] Override http request options.
     */
    public issueGetLabels (owner: string, repo: string, index: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Label>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueGetLabels.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueGetLabels.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueGetLabels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Label>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Label>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a milestone
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id the milestone to get, identified by ID and if not available by name
     * @param {*} [options] Override http request options.
     */
    public issueGetMilestone (owner: string, repo: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Milestone;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueGetMilestone.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueGetMilestone.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueGetMilestone.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Milestone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Milestone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all of a repository's opened milestones
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param state Milestone state, Recognised values are open, closed and all. Defaults to \&quot;open\&quot;
     * @param name filter by milestone name
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public issueGetMilestonesList (owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Milestone>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueGetMilestonesList.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueGetMilestonesList.');
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Milestone>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Milestone>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all comments in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param since if provided, only comments updated since the provided time are returned.
     * @param before if provided, only comments updated before the provided time are returned.
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public issueGetRepoComments (owner: string, repo: string, since?: Date, before?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Comment>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueGetRepoComments.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueGetRepoComments.');
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Comment>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Comment>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repository's issues
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param state whether issue is open or closed
     * @param labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @param q search string
     * @param type filter by type (issues / pulls) if set
     * @param milestones comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
     * @param since Only show items updated after the given time. This is a timestamp in RFC 3339 format
     * @param before Only show items updated before the given time. This is a timestamp in RFC 3339 format
     * @param createdBy Only show items which were created by the the given user
     * @param assignedBy Only show items for which the given user is assigned
     * @param mentionedBy Only show items in which the given user was mentioned
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public issueListIssues (owner: string, repo: string, state?: 'closed' | 'open' | 'all', labels?: string, q?: string, type?: 'issues' | 'pulls', milestones?: string, since?: Date, before?: Date, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueListIssues.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueListIssues.');
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'closed' | 'open' | 'all'");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "string");
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'issues' | 'pulls'");
        }

        if (milestones !== undefined) {
            localVarQueryParameters['milestones'] = ObjectSerializer.serialize(milestones, "string");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "Date");
        }

        if (createdBy !== undefined) {
            localVarQueryParameters['created_by'] = ObjectSerializer.serialize(createdBy, "string");
        }

        if (assignedBy !== undefined) {
            localVarQueryParameters['assigned_by'] = ObjectSerializer.serialize(assignedBy, "string");
        }

        if (mentionedBy !== undefined) {
            localVarQueryParameters['mentioned_by'] = ObjectSerializer.serialize(mentionedBy, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Issue>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all of a repository's labels
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public issueListLabels (owner: string, repo: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Label>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueListLabels.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueListLabels.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Label>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Label>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a reaction to a comment of an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the comment to edit
     * @param content 
     * @param {*} [options] Override http request options.
     */
    public issuePostCommentReaction (owner: string, repo: string, id: number, content?: EditReactionOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Reaction;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{id}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuePostCommentReaction.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuePostCommentReaction.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issuePostCommentReaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(content, "EditReactionOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Reaction;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Reaction");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a reaction to an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param content 
     * @param {*} [options] Override http request options.
     */
    public issuePostIssueReaction (owner: string, repo: string, index: number, content?: EditReactionOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Reaction;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/reactions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issuePostIssueReaction.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issuePostIssueReaction.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issuePostIssueReaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(content, "EditReactionOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Reaction;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Reaction");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a label from an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param id id of the label to remove
     * @param {*} [options] Override http request options.
     */
    public issueRemoveLabel (owner: string, repo: string, index: number, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/labels/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueRemoveLabel.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueRemoveLabel.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueRemoveLabel.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling issueRemoveLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace an issue's labels
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public issueReplaceLabels (owner: string, repo: string, index: number, body?: IssueLabelsOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Label>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueReplaceLabels.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueReplaceLabels.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueReplaceLabels.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "IssueLabelsOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Label>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Label>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset a tracked time of an issue
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue to add tracked time to
     * @param {*} [options] Override http request options.
     */
    public issueResetTime (owner: string, repo: string, index: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/times'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueResetTime.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueResetTime.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueResetTime.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search for issues across the repositories that the user has access to
     * @param state whether issue is open or closed
     * @param labels comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @param milestones comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
     * @param q search string
     * @param priorityRepoId repository to prioritize in the results
     * @param type filter by type (issues / pulls) if set
     * @param since Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @param before Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @param assigned filter (issues / pulls) assigned to you, default is false
     * @param created filter (issues / pulls) created by you, default is false
     * @param mentioned filter (issues / pulls) mentioning you, default is false
     * @param reviewRequested filter pulls requesting your review, default is false
     * @param owner filter by owner
     * @param team filter by team (requires organization owner parameter to be provided)
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public issueSearchIssues (state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: Date, before?: Date, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, owner?: string, team?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }> {
        const localVarPath = this.basePath + '/repos/issues/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "string");
        }

        if (milestones !== undefined) {
            localVarQueryParameters['milestones'] = ObjectSerializer.serialize(milestones, "string");
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (priorityRepoId !== undefined) {
            localVarQueryParameters['priority_repo_id'] = ObjectSerializer.serialize(priorityRepoId, "number");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "Date");
        }

        if (assigned !== undefined) {
            localVarQueryParameters['assigned'] = ObjectSerializer.serialize(assigned, "boolean");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "boolean");
        }

        if (mentioned !== undefined) {
            localVarQueryParameters['mentioned'] = ObjectSerializer.serialize(mentioned, "boolean");
        }

        if (reviewRequested !== undefined) {
            localVarQueryParameters['review_requested'] = ObjectSerializer.serialize(reviewRequested, "boolean");
        }

        if (owner !== undefined) {
            localVarQueryParameters['owner'] = ObjectSerializer.serialize(owner, "string");
        }

        if (team !== undefined) {
            localVarQueryParameters['team'] = ObjectSerializer.serialize(team, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Issue>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Issue>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Start stopwatch on an issue.
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue to create the stopwatch on
     * @param {*} [options] Override http request options.
     */
    public issueStartStopWatch (owner: string, repo: string, index: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/stopwatch/start'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueStartStopWatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueStartStopWatch.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueStartStopWatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Stop an issue's existing stopwatch.
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue to stop the stopwatch on
     * @param {*} [options] Override http request options.
     */
    public issueStopStopWatch (owner: string, repo: string, index: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/stopwatch/stop'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueStopStopWatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueStopStopWatch.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueStopStopWatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get users who subscribed on an issue.
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public issueSubscriptions (owner: string, repo: string, index: number, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/subscriptions'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueSubscriptions.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueSubscriptions.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueSubscriptions.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List an issue's tracked times
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the issue
     * @param user optional filter by user (available for issue managers)
     * @param since Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param before Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public issueTrackedTimes (owner: string, repo: string, index: number, user?: string, since?: Date, before?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TrackedTime>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{index}/times'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling issueTrackedTimes.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling issueTrackedTimes.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling issueTrackedTimes.');
        }

        if (user !== undefined) {
            localVarQueryParameters['user'] = ObjectSerializer.serialize(user, "string");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TrackedTime>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TrackedTime>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MiscellaneousApiApiKeys {
    AccessToken,
    AuthorizationHeaderToken,
    SudoHeader,
    SudoParam,
    TOTPHeader,
    Token,
}

export class MiscellaneousApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AccessToken': new ApiKeyAuth('query', 'access_token'),
        'AuthorizationHeaderToken': new ApiKeyAuth('header', 'Authorization'),
        'BasicAuth': new HttpBasicAuth(),
        'SudoHeader': new ApiKeyAuth('header', 'Sudo'),
        'SudoParam': new ApiKeyAuth('query', 'sudo'),
        'TOTPHeader': new ApiKeyAuth('header', 'X-GITEA-OTP'),
        'Token': new ApiKeyAuth('query', 'token'),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MiscellaneousApiApiKeys, value: string) {
        (this.authentications as any)[MiscellaneousApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.BasicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * 
     * @summary Returns the nodeinfo of the Gitea application
     * @param {*} [options] Override http request options.
     */
    public getNodeInfo (options: any = {}) : Promise<{ response: http.IncomingMessage; body: NodeInfo;  }> {
        const localVarPath = this.basePath + '/nodeinfo';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NodeInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NodeInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get default signing-key.gpg
     * @param {*} [options] Override http request options.
     */
    public getSigningKey (options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/signing-key.gpg';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns the version of the Gitea application
     * @param {*} [options] Override http request options.
     */
    public getVersion (options: any = {}) : Promise<{ response: http.IncomingMessage; body: ServerVersion;  }> {
        const localVarPath = this.basePath + '/version';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ServerVersion;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ServerVersion");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Render a markdown document as HTML
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public renderMarkdown (body?: MarkdownOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/markdown';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MarkdownOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Render raw markdown as HTML
     * @param body Request body to render
     * @param {*} [options] Override http request options.
     */
    public renderMarkdownRaw (body: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/markdown/raw';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling renderMarkdownRaw.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NotificationApiApiKeys {
    AccessToken,
    AuthorizationHeaderToken,
    SudoHeader,
    SudoParam,
    TOTPHeader,
    Token,
}

export class NotificationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AccessToken': new ApiKeyAuth('query', 'access_token'),
        'AuthorizationHeaderToken': new ApiKeyAuth('header', 'Authorization'),
        'BasicAuth': new HttpBasicAuth(),
        'SudoHeader': new ApiKeyAuth('header', 'Sudo'),
        'SudoParam': new ApiKeyAuth('query', 'sudo'),
        'TOTPHeader': new ApiKeyAuth('header', 'X-GITEA-OTP'),
        'Token': new ApiKeyAuth('query', 'token'),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NotificationApiApiKeys, value: string) {
        (this.authentications as any)[NotificationApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.BasicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * 
     * @summary List users's notification threads
     * @param all If true, show notifications marked as read. Default value is false
     * @param statusTypes Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned.
     * @param subjectType filter notifications by subject type
     * @param since Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @param before Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public notifyGetList (all?: boolean, statusTypes?: Array<string>, subjectType?: Array<'issue' | 'pull' | 'commit' | 'repository'>, since?: Date, before?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<NotificationThread>;  }> {
        const localVarPath = this.basePath + '/notifications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (all !== undefined) {
            localVarQueryParameters['all'] = ObjectSerializer.serialize(all, "boolean");
        }

        if (statusTypes !== undefined) {
            localVarQueryParameters['status-types'] = ObjectSerializer.serialize(statusTypes, "Array<string>");
        }

        if (subjectType !== undefined) {
            localVarQueryParameters['subject-type'] = ObjectSerializer.serialize(subjectType, "Array<'issue' | 'pull' | 'commit' | 'repository'>");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<NotificationThread>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<NotificationThread>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List users's notification threads on a specific repo
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param all If true, show notifications marked as read. Default value is false
     * @param statusTypes Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread &amp; pinned
     * @param subjectType filter notifications by subject type
     * @param since Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @param before Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public notifyGetRepoList (owner: string, repo: string, all?: boolean, statusTypes?: Array<string>, subjectType?: Array<'issue' | 'pull' | 'commit' | 'repository'>, since?: Date, before?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<NotificationThread>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/notifications'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling notifyGetRepoList.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling notifyGetRepoList.');
        }

        if (all !== undefined) {
            localVarQueryParameters['all'] = ObjectSerializer.serialize(all, "boolean");
        }

        if (statusTypes !== undefined) {
            localVarQueryParameters['status-types'] = ObjectSerializer.serialize(statusTypes, "Array<string>");
        }

        if (subjectType !== undefined) {
            localVarQueryParameters['subject-type'] = ObjectSerializer.serialize(subjectType, "Array<'issue' | 'pull' | 'commit' | 'repository'>");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<NotificationThread>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<NotificationThread>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get notification thread by ID
     * @param id id of notification thread
     * @param {*} [options] Override http request options.
     */
    public notifyGetThread (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NotificationThread;  }> {
        const localVarPath = this.basePath + '/notifications/threads/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling notifyGetThread.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NotificationThread;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NotificationThread");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Check if unread notifications exist
     * @param {*} [options] Override http request options.
     */
    public notifyNewAvailable (options: any = {}) : Promise<{ response: http.IncomingMessage; body: NotificationCount;  }> {
        const localVarPath = this.basePath + '/notifications/new';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NotificationCount;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NotificationCount");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Mark notification threads as read, pinned or unread
     * @param lastReadAt Describes the last point that notifications were checked. Anything updated since this time will not be updated.
     * @param all If true, mark all notifications on this repo. Default value is false
     * @param statusTypes Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
     * @param toStatus Status to mark notifications as, Defaults to read.
     * @param {*} [options] Override http request options.
     */
    public notifyReadList (lastReadAt?: Date, all?: string, statusTypes?: Array<string>, toStatus?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<NotificationThread>;  }> {
        const localVarPath = this.basePath + '/notifications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (lastReadAt !== undefined) {
            localVarQueryParameters['last_read_at'] = ObjectSerializer.serialize(lastReadAt, "Date");
        }

        if (all !== undefined) {
            localVarQueryParameters['all'] = ObjectSerializer.serialize(all, "string");
        }

        if (statusTypes !== undefined) {
            localVarQueryParameters['status-types'] = ObjectSerializer.serialize(statusTypes, "Array<string>");
        }

        if (toStatus !== undefined) {
            localVarQueryParameters['to-status'] = ObjectSerializer.serialize(toStatus, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<NotificationThread>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<NotificationThread>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Mark notification threads as read, pinned or unread on a specific repo
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param all If true, mark all notifications on this repo. Default value is false
     * @param statusTypes Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
     * @param toStatus Status to mark notifications as. Defaults to read.
     * @param lastReadAt Describes the last point that notifications were checked. Anything updated since this time will not be updated.
     * @param {*} [options] Override http request options.
     */
    public notifyReadRepoList (owner: string, repo: string, all?: string, statusTypes?: Array<string>, toStatus?: string, lastReadAt?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<NotificationThread>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/notifications'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling notifyReadRepoList.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling notifyReadRepoList.');
        }

        if (all !== undefined) {
            localVarQueryParameters['all'] = ObjectSerializer.serialize(all, "string");
        }

        if (statusTypes !== undefined) {
            localVarQueryParameters['status-types'] = ObjectSerializer.serialize(statusTypes, "Array<string>");
        }

        if (toStatus !== undefined) {
            localVarQueryParameters['to-status'] = ObjectSerializer.serialize(toStatus, "string");
        }

        if (lastReadAt !== undefined) {
            localVarQueryParameters['last_read_at'] = ObjectSerializer.serialize(lastReadAt, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<NotificationThread>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<NotificationThread>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Mark notification thread as read by ID
     * @param id id of notification thread
     * @param toStatus Status to mark notifications as
     * @param {*} [options] Override http request options.
     */
    public notifyReadThread (id: string, toStatus?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NotificationThread;  }> {
        const localVarPath = this.basePath + '/notifications/threads/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling notifyReadThread.');
        }

        if (toStatus !== undefined) {
            localVarQueryParameters['to-status'] = ObjectSerializer.serialize(toStatus, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NotificationThread;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NotificationThread");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrganizationApiApiKeys {
    AccessToken,
    AuthorizationHeaderToken,
    SudoHeader,
    SudoParam,
    TOTPHeader,
    Token,
}

export class OrganizationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AccessToken': new ApiKeyAuth('query', 'access_token'),
        'AuthorizationHeaderToken': new ApiKeyAuth('header', 'Authorization'),
        'BasicAuth': new HttpBasicAuth(),
        'SudoHeader': new ApiKeyAuth('header', 'Sudo'),
        'SudoParam': new ApiKeyAuth('query', 'sudo'),
        'TOTPHeader': new ApiKeyAuth('header', 'X-GITEA-OTP'),
        'Token': new ApiKeyAuth('query', 'token'),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationApiApiKeys, value: string) {
        (this.authentications as any)[OrganizationApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.BasicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * 
     * @summary Create a repository in an organization
     * @param org name of organization
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createOrgRepo (org: string, body?: CreateRepoOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/repos'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling createOrgRepo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateRepoOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a repository in an organization
     * @param org name of organization
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createOrgRepoDeprecated (org: string, body?: CreateRepoOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/org/{org}/repos'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling createOrgRepoDeprecated.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateRepoOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a team member
     * @param id id of the team
     * @param username username of the user to add
     * @param {*} [options] Override http request options.
     */
    public orgAddTeamMember (id: number, username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{id}/members/{username}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgAddTeamMember.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgAddTeamMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a repository to a team
     * @param id id of the team
     * @param org organization that owns the repo to add
     * @param repo name of the repo to add
     * @param {*} [options] Override http request options.
     */
    public orgAddTeamRepository (id: number, org: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{id}/repos/{org}/{repo}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgAddTeamRepository.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgAddTeamRepository.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling orgAddTeamRepository.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Conceal a user's membership
     * @param org name of the organization
     * @param username username of the user
     * @param {*} [options] Override http request options.
     */
    public orgConcealMember (org: string, username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/public_members/{username}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgConcealMember.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgConcealMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create an organization
     * @param organization 
     * @param {*} [options] Override http request options.
     */
    public orgCreate (organization: CreateOrgOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Organization;  }> {
        const localVarPath = this.basePath + '/orgs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling orgCreate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(organization, "CreateOrgOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Organization;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Organization");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a hook
     * @param org name of the organization
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public orgCreateHook (org: string, body: CreateHookOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Hook;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/hooks/'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgCreateHook.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling orgCreateHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateHookOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Hook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Hook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a label for an organization
     * @param org name of the organization
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public orgCreateLabel (org: string, body?: CreateLabelOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/labels'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgCreateLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateLabelOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Label");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a team
     * @param org name of the organization
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public orgCreateTeam (org: string, body?: CreateTeamOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Team;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/teams'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgCreateTeam.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateTeamOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Team;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Team");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an organization
     * @param org organization that is to be deleted
     * @param {*} [options] Override http request options.
     */
    public orgDelete (org: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a hook
     * @param org name of the organization
     * @param id id of the hook to delete
     * @param {*} [options] Override http request options.
     */
    public orgDeleteHook (org: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/hooks/{id}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgDeleteHook.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgDeleteHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a label
     * @param org name of the organization
     * @param id id of the label to delete
     * @param {*} [options] Override http request options.
     */
    public orgDeleteLabel (org: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/labels/{id}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgDeleteLabel.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgDeleteLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a member from an organization
     * @param org name of the organization
     * @param username username of the user
     * @param {*} [options] Override http request options.
     */
    public orgDeleteMember (org: string, username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/members/{username}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgDeleteMember.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgDeleteMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a team
     * @param id id of the team to delete
     * @param {*} [options] Override http request options.
     */
    public orgDeleteTeam (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgDeleteTeam.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit an organization
     * @param org name of the organization to edit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public orgEdit (org: string, body: EditOrgOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Organization;  }> {
        const localVarPath = this.basePath + '/orgs/{org}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgEdit.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling orgEdit.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditOrgOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Organization;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Organization");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a hook
     * @param org name of the organization
     * @param id id of the hook to update
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public orgEditHook (org: string, id: number, body?: EditHookOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Hook;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/hooks/{id}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgEditHook.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgEditHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditHookOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Hook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Hook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a label
     * @param org name of the organization
     * @param id id of the label to edit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public orgEditLabel (org: string, id: number, body?: EditLabelOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/labels/{id}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgEditLabel.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgEditLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditLabelOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Label");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a team
     * @param id id of the team to edit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public orgEditTeam (id: number, body?: EditTeamOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Team;  }> {
        const localVarPath = this.basePath + '/teams/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgEditTeam.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditTeamOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Team;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Team");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an organization
     * @param org name of the organization to get
     * @param {*} [options] Override http request options.
     */
    public orgGet (org: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Organization;  }> {
        const localVarPath = this.basePath + '/orgs/{org}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Organization;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Organization");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get list of organizations
     * @param lang If the org has one or more repos with the given language(s), the org will be in the results. Multiple lang&#39;s are ORed.
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public orgGetAll (lang?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Organization>;  }> {
        const localVarPath = this.basePath + '/orgs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (lang !== undefined) {
            localVarQueryParameters['lang'] = ObjectSerializer.serialize(lang, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Organization>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Organization>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a hook
     * @param org name of the organization
     * @param id id of the hook to get
     * @param {*} [options] Override http request options.
     */
    public orgGetHook (org: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Hook;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/hooks/{id}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgGetHook.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgGetHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Hook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Hook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single label
     * @param org name of the organization
     * @param id id of the label to get
     * @param {*} [options] Override http request options.
     */
    public orgGetLabel (org: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/labels/{id}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgGetLabel.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgGetLabel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Label");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a team
     * @param id id of the team to get
     * @param {*} [options] Override http request options.
     */
    public orgGetTeam (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Team;  }> {
        const localVarPath = this.basePath + '/teams/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgGetTeam.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Team;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Team");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user permissions in organization
     * @param username username of user
     * @param org name of the organization
     * @param {*} [options] Override http request options.
     */
    public orgGetUserPermissions (username: string, org: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OrganizationPermissions;  }> {
        const localVarPath = this.basePath + '/users/{username}/orgs/{org}/permissions'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgGetUserPermissions.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgGetUserPermissions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OrganizationPermissions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrganizationPermissions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Check if a user is a member of an organization
     * @param org name of the organization
     * @param username username of the user
     * @param {*} [options] Override http request options.
     */
    public orgIsMember (org: string, username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/members/{username}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgIsMember.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgIsMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Check if a user is a public member of an organization
     * @param org name of the organization
     * @param username username of the user
     * @param {*} [options] Override http request options.
     */
    public orgIsPublicMember (org: string, username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/public_members/{username}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgIsPublicMember.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgIsPublicMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the current user's organizations
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public orgListCurrentUserOrgs (page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Organization>;  }> {
        const localVarPath = this.basePath + '/user/orgs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Organization>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Organization>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List an organization's webhooks
     * @param org name of the organization
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public orgListHooks (org: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Hook>;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/hooks'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgListHooks.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Hook>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Hook>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List an organization's labels
     * @param org name of the organization
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public orgListLabels (org: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Label>;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/labels'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgListLabels.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Label>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Label>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List an organization's members
     * @param org name of the organization
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public orgListMembers (org: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/members'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgListMembers.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List an organization's public members
     * @param org name of the organization
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public orgListPublicMembers (org: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/public_members'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgListPublicMembers.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List an organization's repos
     * @param org name of the organization
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public orgListRepos (org: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/repos'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgListRepos.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Repository>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a particular member of team
     * @param id id of the team
     * @param username username of the member to list
     * @param {*} [options] Override http request options.
     */
    public orgListTeamMember (id: number, username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: User;  }> {
        const localVarPath = this.basePath + '/teams/{id}/members/{username}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgListTeamMember.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgListTeamMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a team's members
     * @param id id of the team
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public orgListTeamMembers (id: number, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/teams/{id}/members'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgListTeamMembers.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a team's repos
     * @param id id of the team
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public orgListTeamRepos (id: number, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }> {
        const localVarPath = this.basePath + '/teams/{id}/repos'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgListTeamRepos.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Repository>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List an organization's teams
     * @param org name of the organization
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public orgListTeams (org: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Team>;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/teams'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgListTeams.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Team>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Team>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a user's organizations
     * @param username username of user
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public orgListUserOrgs (username: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Organization>;  }> {
        const localVarPath = this.basePath + '/users/{username}/orgs'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgListUserOrgs.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Organization>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Organization>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Publicize a user's membership
     * @param org name of the organization
     * @param username username of the user
     * @param {*} [options] Override http request options.
     */
    public orgPublicizeMember (org: string, username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/public_members/{username}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgPublicizeMember.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgPublicizeMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a team member
     * @param id id of the team
     * @param username username of the user to remove
     * @param {*} [options] Override http request options.
     */
    public orgRemoveTeamMember (id: number, username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{id}/members/{username}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgRemoveTeamMember.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgRemoveTeamMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This does not delete the repository, it only removes the repository from the team.
     * @summary Remove a repository from a team
     * @param id id of the team
     * @param org organization that owns the repo to remove
     * @param repo name of the repo to remove
     * @param {*} [options] Override http request options.
     */
    public orgRemoveTeamRepository (id: number, org: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{id}/repos/{org}/{repo}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling orgRemoveTeamRepository.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgRemoveTeamRepository.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling orgRemoveTeamRepository.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search for teams within an organization
     * @param org name of the organization
     * @param q keywords to search
     * @param includeDesc include search within team description (defaults to true)
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public teamSearch (org: string, q?: string, includeDesc?: boolean, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/teams/search'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling teamSearch.');
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (includeDesc !== undefined) {
            localVarQueryParameters['include_desc'] = ObjectSerializer.serialize(includeDesc, "boolean");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RepositoryApiApiKeys {
    AccessToken,
    AuthorizationHeaderToken,
    SudoHeader,
    SudoParam,
    TOTPHeader,
    Token,
}

export class RepositoryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AccessToken': new ApiKeyAuth('query', 'access_token'),
        'AuthorizationHeaderToken': new ApiKeyAuth('header', 'Authorization'),
        'BasicAuth': new HttpBasicAuth(),
        'SudoHeader': new ApiKeyAuth('header', 'Sudo'),
        'SudoParam': new ApiKeyAuth('query', 'sudo'),
        'TOTPHeader': new ApiKeyAuth('header', 'X-GITEA-OTP'),
        'Token': new ApiKeyAuth('query', 'token'),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RepositoryApiApiKeys, value: string) {
        (this.authentications as any)[RepositoryApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.BasicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * 
     * @summary Accept a repo transfer
     * @param owner owner of the repo to transfer
     * @param repo name of the repo to transfer
     * @param {*} [options] Override http request options.
     */
    public acceptRepoTransfer (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/transfer/accept'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling acceptRepoTransfer.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling acceptRepoTransfer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a repository
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createCurrentUserRepo (body?: CreateRepoOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/user/repos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateRepoOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fork a repository
     * @param owner owner of the repo to fork
     * @param repo name of the repo to fork
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createFork (owner: string, repo: string, body?: CreateForkOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/forks'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling createFork.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling createFork.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateForkOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a repository using a template
     * @param templateOwner name of the template repository owner
     * @param templateRepo name of the template repository
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public generateRepo (templateOwner: string, templateRepo: string, body?: GenerateRepoOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/repos/{template_owner}/{template_repo}/generate'
            .replace('{' + 'template_owner' + '}', encodeURIComponent(String(templateOwner)))
            .replace('{' + 'template_repo' + '}', encodeURIComponent(String(templateRepo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateOwner' is not null or undefined
        if (templateOwner === null || templateOwner === undefined) {
            throw new Error('Required parameter templateOwner was null or undefined when calling generateRepo.');
        }

        // verify required parameter 'templateRepo' is not null or undefined
        if (templateRepo === null || templateRepo === undefined) {
            throw new Error('Required parameter templateRepo was null or undefined when calling generateRepo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "GenerateRepoOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the tag object of an annotated tag (not lightweight tags)
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param sha sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
     * @param {*} [options] Override http request options.
     */
    public getAnnotatedTag (owner: string, repo: string, sha: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AnnotatedTag;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/tags/{sha}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'sha' + '}', encodeURIComponent(String(sha)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling getAnnotatedTag.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling getAnnotatedTag.');
        }

        // verify required parameter 'sha' is not null or undefined
        if (sha === null || sha === undefined) {
            throw new Error('Required parameter sha was null or undefined when calling getAnnotatedTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnnotatedTag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnnotatedTag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the blob of a repository.
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param sha sha of the commit
     * @param {*} [options] Override http request options.
     */
    public getBlob (owner: string, repo: string, sha: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GitBlobResponse;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/blobs/{sha}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'sha' + '}', encodeURIComponent(String(sha)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling getBlob.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling getBlob.');
        }

        // verify required parameter 'sha' is not null or undefined
        if (sha === null || sha === undefined) {
            throw new Error('Required parameter sha was null or undefined when calling getBlob.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GitBlobResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GitBlobResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the tree of a repository.
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param sha sha of the commit
     * @param recursive show all directories and files
     * @param page page number; the &#39;truncated&#39; field in the response will be true if there are still more items after this page, false if the last page
     * @param perPage number of items per page
     * @param {*} [options] Override http request options.
     */
    public getTree (owner: string, repo: string, sha: string, recursive?: boolean, page?: number, perPage?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GitTreeResponse;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/trees/{sha}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'sha' + '}', encodeURIComponent(String(sha)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling getTree.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling getTree.');
        }

        // verify required parameter 'sha' is not null or undefined
        if (sha === null || sha === undefined) {
            throw new Error('Required parameter sha was null or undefined when calling getTree.');
        }

        if (recursive !== undefined) {
            localVarQueryParameters['recursive'] = ObjectSerializer.serialize(recursive, "boolean");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GitTreeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GitTreeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repository's forks
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public listForks (owner: string, repo: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/forks'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling listForks.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling listForks.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Repository>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reject a repo transfer
     * @param owner owner of the repo to transfer
     * @param repo name of the repo to transfer
     * @param {*} [options] Override http request options.
     */
    public rejectRepoTransfer (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/transfer/reject'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling rejectRepoTransfer.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling rejectRepoTransfer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a collaborator to a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param collaborator username of the collaborator to add
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoAddCollaborator (owner: string, repo: string, collaborator: string, body?: AddCollaboratorOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/collaborators/{collaborator}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'collaborator' + '}', encodeURIComponent(String(collaborator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoAddCollaborator.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoAddCollaborator.');
        }

        // verify required parameter 'collaborator' is not null or undefined
        if (collaborator === null || collaborator === undefined) {
            throw new Error('Required parameter collaborator was null or undefined when calling repoAddCollaborator.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AddCollaboratorOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a team to a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param team team name
     * @param {*} [options] Override http request options.
     */
    public repoAddTeam (owner: string, repo: string, team: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/teams/{team}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'team' + '}', encodeURIComponent(String(team)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoAddTeam.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoAddTeam.');
        }

        // verify required parameter 'team' is not null or undefined
        if (team === null || team === undefined) {
            throw new Error('Required parameter team was null or undefined when calling repoAddTeam.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a topic to a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param topic name of the topic to add
     * @param {*} [options] Override http request options.
     */
    public repoAddTopic (owner: string, repo: string, topic: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/topics/{topic}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'topic' + '}', encodeURIComponent(String(topic)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoAddTopic.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoAddTopic.');
        }

        // verify required parameter 'topic' is not null or undefined
        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling repoAddTopic.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Check if a user is a collaborator of a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param collaborator username of the collaborator
     * @param {*} [options] Override http request options.
     */
    public repoCheckCollaborator (owner: string, repo: string, collaborator: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/collaborators/{collaborator}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'collaborator' + '}', encodeURIComponent(String(collaborator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCheckCollaborator.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCheckCollaborator.');
        }

        // verify required parameter 'collaborator' is not null or undefined
        if (collaborator === null || collaborator === undefined) {
            throw new Error('Required parameter collaborator was null or undefined when calling repoCheckCollaborator.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Check if a team is assigned to a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param team team name
     * @param {*} [options] Override http request options.
     */
    public repoCheckTeam (owner: string, repo: string, team: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Team;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/teams/{team}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'team' + '}', encodeURIComponent(String(team)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCheckTeam.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCheckTeam.');
        }

        // verify required parameter 'team' is not null or undefined
        if (team === null || team === undefined) {
            throw new Error('Required parameter team was null or undefined when calling repoCheckTeam.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Team;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Team");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a branch
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreateBranch (owner: string, repo: string, body?: CreateBranchRepoOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Branch;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/branches'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreateBranch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreateBranch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateBranchRepoOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Branch;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Branch");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a branch protections for a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreateBranchProtection (owner: string, repo: string, body?: CreateBranchProtectionOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BranchProtection;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/branch_protections'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreateBranchProtection.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreateBranchProtection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateBranchProtectionOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BranchProtection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BranchProtection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a file in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param filepath path of the file to create
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreateFile (owner: string, repo: string, filepath: string, body: CreateFileOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FileResponse;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/contents/{filepath}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'filepath' + '}', encodeURIComponent(String(filepath)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreateFile.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreateFile.');
        }

        // verify required parameter 'filepath' is not null or undefined
        if (filepath === null || filepath === undefined) {
            throw new Error('Required parameter filepath was null or undefined when calling repoCreateFile.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repoCreateFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateFileOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FileResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FileResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a hook
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreateHook (owner: string, repo: string, body?: CreateHookOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Hook;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreateHook.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreateHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateHookOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Hook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Hook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a key to a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreateKey (owner: string, repo: string, body?: CreateKeyOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DeployKey;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/keys'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreateKey.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreateKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateKeyOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeployKey;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeployKey");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreatePullRequest (owner: string, repo: string, body?: CreatePullRequestOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullRequest;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreatePullRequest.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreatePullRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreatePullRequestOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a review to an pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreatePullReview (owner: string, repo: string, index: number, body: CreatePullReviewOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullReview;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/reviews'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreatePullReview.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreatePullReview.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoCreatePullReview.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repoCreatePullReview.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreatePullReviewOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullReview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullReview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary create review requests for a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreatePullReviewRequests (owner: string, repo: string, index: number, body: PullReviewRequestOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PullReview>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/requested_reviewers'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreatePullReviewRequests.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreatePullReviewRequests.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoCreatePullReviewRequests.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repoCreatePullReviewRequests.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PullReviewRequestOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PullReview>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PullReview>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a release
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreateRelease (owner: string, repo: string, body?: CreateReleaseOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Release;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreateRelease.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreateRelease.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateReleaseOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Release;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Release");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a release attachment
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the release
     * @param attachment attachment to upload
     * @param name name of the attachment
     * @param {*} [options] Override http request options.
     */
    public repoCreateReleaseAttachment (owner: string, repo: string, id: number, attachment: Buffer, name?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Attachment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}/assets'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreateReleaseAttachment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreateReleaseAttachment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoCreateReleaseAttachment.');
        }

        // verify required parameter 'attachment' is not null or undefined
        if (attachment === null || attachment === undefined) {
            throw new Error('Required parameter attachment was null or undefined when calling repoCreateReleaseAttachment.');
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (attachment !== undefined) {
            localVarFormParams['attachment'] = attachment;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Attachment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Attachment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a commit status
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param sha sha of the commit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreateStatus (owner: string, repo: string, sha: string, body?: CreateStatusOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CommitStatus;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/statuses/{sha}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'sha' + '}', encodeURIComponent(String(sha)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreateStatus.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreateStatus.');
        }

        // verify required parameter 'sha' is not null or undefined
        if (sha === null || sha === undefined) {
            throw new Error('Required parameter sha was null or undefined when calling repoCreateStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateStatusOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CommitStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CommitStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new git tag in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreateTag (owner: string, repo: string, body?: CreateTagOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Tag;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/tags'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreateTag.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreateTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateTagOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Tag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Tag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a wiki page
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoCreateWikiPage (owner: string, repo: string, body?: CreateWikiPageOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WikiPage;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/wiki/new'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoCreateWikiPage.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoCreateWikiPage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateWikiPageOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WikiPage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WikiPage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a repository
     * @param owner owner of the repo to delete
     * @param repo name of the repo to delete
     * @param {*} [options] Override http request options.
     */
    public repoDelete (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a specific branch from a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param branch branch to delete
     * @param {*} [options] Override http request options.
     */
    public repoDeleteBranch (owner: string, repo: string, branch: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/branches/{branch}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'branch' + '}', encodeURIComponent(String(branch)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteBranch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteBranch.');
        }

        // verify required parameter 'branch' is not null or undefined
        if (branch === null || branch === undefined) {
            throw new Error('Required parameter branch was null or undefined when calling repoDeleteBranch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a specific branch protection for the repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param name name of protected branch
     * @param {*} [options] Override http request options.
     */
    public repoDeleteBranchProtection (owner: string, repo: string, name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/branch_protections/{name}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteBranchProtection.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteBranchProtection.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling repoDeleteBranchProtection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a collaborator from a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param collaborator username of the collaborator to delete
     * @param {*} [options] Override http request options.
     */
    public repoDeleteCollaborator (owner: string, repo: string, collaborator: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/collaborators/{collaborator}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'collaborator' + '}', encodeURIComponent(String(collaborator)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteCollaborator.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteCollaborator.');
        }

        // verify required parameter 'collaborator' is not null or undefined
        if (collaborator === null || collaborator === undefined) {
            throw new Error('Required parameter collaborator was null or undefined when calling repoDeleteCollaborator.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a file in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param filepath path of the file to delete
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoDeleteFile (owner: string, repo: string, filepath: string, body: DeleteFileOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FileDeleteResponse;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/contents/{filepath}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'filepath' + '}', encodeURIComponent(String(filepath)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteFile.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteFile.');
        }

        // verify required parameter 'filepath' is not null or undefined
        if (filepath === null || filepath === undefined) {
            throw new Error('Required parameter filepath was null or undefined when calling repoDeleteFile.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repoDeleteFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DeleteFileOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FileDeleteResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FileDeleteResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a Git hook in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the hook to get
     * @param {*} [options] Override http request options.
     */
    public repoDeleteGitHook (owner: string, repo: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/git/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteGitHook.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteGitHook.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoDeleteGitHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a hook in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the hook to delete
     * @param {*} [options] Override http request options.
     */
    public repoDeleteHook (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteHook.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteHook.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoDeleteHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a key from a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the key to delete
     * @param {*} [options] Override http request options.
     */
    public repoDeleteKey (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/keys/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteKey.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteKey.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoDeleteKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a specific review from a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request
     * @param id id of the review
     * @param {*} [options] Override http request options.
     */
    public repoDeletePullReview (owner: string, repo: string, index: number, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeletePullReview.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeletePullReview.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoDeletePullReview.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoDeletePullReview.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary cancel review requests for a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoDeletePullReviewRequests (owner: string, repo: string, index: number, body: PullReviewRequestOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/requested_reviewers'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeletePullReviewRequests.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeletePullReviewRequests.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoDeletePullReviewRequests.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repoDeletePullReviewRequests.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PullReviewRequestOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a release
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the release to delete
     * @param {*} [options] Override http request options.
     */
    public repoDeleteRelease (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteRelease.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteRelease.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoDeleteRelease.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a release attachment
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the release
     * @param attachmentId id of the attachment to delete
     * @param {*} [options] Override http request options.
     */
    public repoDeleteReleaseAttachment (owner: string, repo: string, id: number, attachmentId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'attachment_id' + '}', encodeURIComponent(String(attachmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteReleaseAttachment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteReleaseAttachment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoDeleteReleaseAttachment.');
        }

        // verify required parameter 'attachmentId' is not null or undefined
        if (attachmentId === null || attachmentId === undefined) {
            throw new Error('Required parameter attachmentId was null or undefined when calling repoDeleteReleaseAttachment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a release by tag name
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param tag tag name of the release to delete
     * @param {*} [options] Override http request options.
     */
    public repoDeleteReleaseByTag (owner: string, repo: string, tag: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/tags/{tag}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'tag' + '}', encodeURIComponent(String(tag)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteReleaseByTag.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteReleaseByTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling repoDeleteReleaseByTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a repository's tag by name
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param tag name of tag to delete
     * @param {*} [options] Override http request options.
     */
    public repoDeleteTag (owner: string, repo: string, tag: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/tags/{tag}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'tag' + '}', encodeURIComponent(String(tag)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteTag.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling repoDeleteTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a team from a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param team team name
     * @param {*} [options] Override http request options.
     */
    public repoDeleteTeam (owner: string, repo: string, team: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/teams/{team}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'team' + '}', encodeURIComponent(String(team)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteTeam.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteTeam.');
        }

        // verify required parameter 'team' is not null or undefined
        if (team === null || team === undefined) {
            throw new Error('Required parameter team was null or undefined when calling repoDeleteTeam.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a topic from a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param topic name of the topic to delete
     * @param {*} [options] Override http request options.
     */
    public repoDeleteTopic (owner: string, repo: string, topic: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/topics/{topic}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'topic' + '}', encodeURIComponent(String(topic)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteTopic.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteTopic.');
        }

        // verify required parameter 'topic' is not null or undefined
        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling repoDeleteTopic.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a wiki page
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param pageName name of the page
     * @param {*} [options] Override http request options.
     */
    public repoDeleteWikiPage (owner: string, repo: string, pageName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/wiki/page/{pageName}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'pageName' + '}', encodeURIComponent(String(pageName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDeleteWikiPage.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDeleteWikiPage.');
        }

        // verify required parameter 'pageName' is not null or undefined
        if (pageName === null || pageName === undefined) {
            throw new Error('Required parameter pageName was null or undefined when calling repoDeleteWikiPage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Dismiss a review for a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request
     * @param id id of the review
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoDismissPullReview (owner: string, repo: string, index: number, id: number, body: DismissPullReviewOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullReview;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDismissPullReview.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDismissPullReview.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoDismissPullReview.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoDismissPullReview.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repoDismissPullReview.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DismissPullReviewOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullReview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullReview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a commit's diff or patch
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param sha SHA of the commit to get
     * @param diffType whether the output is diff or patch
     * @param {*} [options] Override http request options.
     */
    public repoDownloadCommitDiffOrPatch (owner: string, repo: string, sha: string, diffType: 'diff' | 'patch', options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/commits/{sha}.{diffType}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'sha' + '}', encodeURIComponent(String(sha)))
            .replace('{' + 'diffType' + '}', encodeURIComponent(String(diffType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDownloadCommitDiffOrPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDownloadCommitDiffOrPatch.');
        }

        // verify required parameter 'sha' is not null or undefined
        if (sha === null || sha === undefined) {
            throw new Error('Required parameter sha was null or undefined when calling repoDownloadCommitDiffOrPatch.');
        }

        // verify required parameter 'diffType' is not null or undefined
        if (diffType === null || diffType === undefined) {
            throw new Error('Required parameter diffType was null or undefined when calling repoDownloadCommitDiffOrPatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a pull request diff or patch
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request to get
     * @param diffType whether the output is diff or patch
     * @param binary whether to include binary file changes. if true, the diff is applicable with &#x60;git apply&#x60;
     * @param {*} [options] Override http request options.
     */
    public repoDownloadPullDiffOrPatch (owner: string, repo: string, index: number, diffType: 'diff' | 'patch', binary?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}.{diffType}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'diffType' + '}', encodeURIComponent(String(diffType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoDownloadPullDiffOrPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoDownloadPullDiffOrPatch.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoDownloadPullDiffOrPatch.');
        }

        // verify required parameter 'diffType' is not null or undefined
        if (diffType === null || diffType === undefined) {
            throw new Error('Required parameter diffType was null or undefined when calling repoDownloadPullDiffOrPatch.');
        }

        if (binary !== undefined) {
            localVarQueryParameters['binary'] = ObjectSerializer.serialize(binary, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a repository's properties. Only fields that are set will be changed.
     * @param owner owner of the repo to edit
     * @param repo name of the repo to edit
     * @param body Properties of a repo that you can edit
     * @param {*} [options] Override http request options.
     */
    public repoEdit (owner: string, repo: string, body?: EditRepoOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoEdit.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoEdit.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditRepoOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a branch protections for a repository. Only fields that are set will be changed
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param name name of protected branch
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoEditBranchProtection (owner: string, repo: string, name: string, body?: EditBranchProtectionOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BranchProtection;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/branch_protections/{name}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoEditBranchProtection.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoEditBranchProtection.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling repoEditBranchProtection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditBranchProtectionOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BranchProtection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BranchProtection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a Git hook in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the hook to get
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoEditGitHook (owner: string, repo: string, id: string, body?: EditGitHookOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GitHook;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/git/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoEditGitHook.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoEditGitHook.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoEditGitHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditGitHookOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GitHook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GitHook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a hook in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id index of the hook
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoEditHook (owner: string, repo: string, id: number, body?: EditHookOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Hook;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoEditHook.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoEditHook.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoEditHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditHookOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Hook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Hook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request to edit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoEditPullRequest (owner: string, repo: string, index: number, body?: EditPullRequestOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullRequest;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoEditPullRequest.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoEditPullRequest.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoEditPullRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditPullRequestOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a release
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the release to edit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoEditRelease (owner: string, repo: string, id: number, body?: EditReleaseOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Release;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoEditRelease.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoEditRelease.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoEditRelease.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditReleaseOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Release;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Release");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a release attachment
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the release
     * @param attachmentId id of the attachment to edit
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoEditReleaseAttachment (owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Attachment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'attachment_id' + '}', encodeURIComponent(String(attachmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoEditReleaseAttachment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoEditReleaseAttachment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoEditReleaseAttachment.');
        }

        // verify required parameter 'attachmentId' is not null or undefined
        if (attachmentId === null || attachmentId === undefined) {
            throw new Error('Required parameter attachmentId was null or undefined when calling repoEditReleaseAttachment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditAttachmentOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Attachment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Attachment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a wiki page
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param pageName name of the page
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoEditWikiPage (owner: string, repo: string, pageName: string, body?: CreateWikiPageOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WikiPage;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/wiki/page/{pageName}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'pageName' + '}', encodeURIComponent(String(pageName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoEditWikiPage.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoEditWikiPage.');
        }

        // verify required parameter 'pageName' is not null or undefined
        if (pageName === null || pageName === undefined) {
            throw new Error('Required parameter pageName was null or undefined when calling repoEditWikiPage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateWikiPageOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WikiPage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WikiPage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public repoGet (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a list of all commits from a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param sha SHA or branch to start listing commits from (usually &#39;master&#39;)
     * @param path filepath of a file/dir
     * @param page page number of results to return (1-based)
     * @param limit page size of results (ignored if used with &#39;path&#39;)
     * @param {*} [options] Override http request options.
     */
    public repoGetAllCommits (owner: string, repo: string, sha?: string, path?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Commit>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/commits'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetAllCommits.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetAllCommits.');
        }

        if (sha !== undefined) {
            localVarQueryParameters['sha'] = ObjectSerializer.serialize(sha, "string");
        }

        if (path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(path, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Commit>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Commit>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an archive of a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param archive the git reference for download with attached archive format (e.g. master.zip)
     * @param {*} [options] Override http request options.
     */
    public repoGetArchive (owner: string, repo: string, archive: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/archive/{archive}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'archive' + '}', encodeURIComponent(String(archive)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetArchive.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetArchive.');
        }

        // verify required parameter 'archive' is not null or undefined
        if (archive === null || archive === undefined) {
            throw new Error('Required parameter archive was null or undefined when calling repoGetArchive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return all users that have write access and can be assigned to issues
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public repoGetAssignees (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/assignees'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetAssignees.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetAssignees.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a specific branch from a repository, including its effective branch protection
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param branch branch to get
     * @param {*} [options] Override http request options.
     */
    public repoGetBranch (owner: string, repo: string, branch: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Branch;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/branches/{branch}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'branch' + '}', encodeURIComponent(String(branch)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetBranch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetBranch.');
        }

        // verify required parameter 'branch' is not null or undefined
        if (branch === null || branch === undefined) {
            throw new Error('Required parameter branch was null or undefined when calling repoGetBranch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Branch;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Branch");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a specific branch protection for the repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param name name of protected branch
     * @param {*} [options] Override http request options.
     */
    public repoGetBranchProtection (owner: string, repo: string, name: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: BranchProtection;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/branch_protections/{name}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetBranchProtection.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetBranchProtection.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling repoGetBranchProtection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: BranchProtection;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BranchProtection");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a repository by id
     * @param id id of the repo to get
     * @param {*} [options] Override http request options.
     */
    public repoGetByID (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/repositories/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoGetByID.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a commit's combined status, by branch/tag/commit reference
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param ref name of branch/tag/commit
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoGetCombinedStatusByRef (owner: string, repo: string, ref: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CombinedStatus;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/commits/{ref}/status'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'ref' + '}', encodeURIComponent(String(ref)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetCombinedStatusByRef.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetCombinedStatusByRef.');
        }

        // verify required parameter 'ref' is not null or undefined
        if (ref === null || ref === undefined) {
            throw new Error('Required parameter ref was null or undefined when calling repoGetCombinedStatusByRef.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CombinedStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CombinedStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param filepath path of the dir, file, symlink or submodule in the repo
     * @param ref The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request options.
     */
    public repoGetContents (owner: string, repo: string, filepath: string, ref?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ContentsResponse;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/contents/{filepath}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'filepath' + '}', encodeURIComponent(String(filepath)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetContents.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetContents.');
        }

        // verify required parameter 'filepath' is not null or undefined
        if (filepath === null || filepath === undefined) {
            throw new Error('Required parameter filepath was null or undefined when calling repoGetContents.');
        }

        if (ref !== undefined) {
            localVarQueryParameters['ref'] = ObjectSerializer.serialize(ref, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ContentsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ContentsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the metadata of all the entries of the root dir
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param ref The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request options.
     */
    public repoGetContentsList (owner: string, repo: string, ref?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ContentsResponse>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/contents'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetContentsList.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetContentsList.');
        }

        if (ref !== undefined) {
            localVarQueryParameters['ref'] = ObjectSerializer.serialize(ref, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ContentsResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ContentsResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the EditorConfig definitions of a file in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param filepath filepath of file to get
     * @param {*} [options] Override http request options.
     */
    public repoGetEditorConfig (owner: string, repo: string, filepath: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/editorconfig/{filepath}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'filepath' + '}', encodeURIComponent(String(filepath)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetEditorConfig.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetEditorConfig.');
        }

        // verify required parameter 'filepath' is not null or undefined
        if (filepath === null || filepath === undefined) {
            throw new Error('Required parameter filepath was null or undefined when calling repoGetEditorConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a Git hook
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the hook to get
     * @param {*} [options] Override http request options.
     */
    public repoGetGitHook (owner: string, repo: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GitHook;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/git/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetGitHook.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetGitHook.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoGetGitHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GitHook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GitHook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a hook
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the hook to get
     * @param {*} [options] Override http request options.
     */
    public repoGetHook (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Hook;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetHook.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetHook.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoGetHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Hook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Hook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get available issue templates for a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public repoGetIssueTemplates (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<IssueTemplate>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issue_templates'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetIssueTemplates.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetIssueTemplates.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<IssueTemplate>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<IssueTemplate>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a repository's key by id
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the key to get
     * @param {*} [options] Override http request options.
     */
    public repoGetKey (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DeployKey;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/keys/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetKey.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetKey.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoGetKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeployKey;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeployKey");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get languages and number of bytes of code written
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public repoGetLanguages (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: { [key: string]: number; };  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/languages'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetLanguages.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetLanguages.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: { [key: string]: number; };  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "{ [key: string]: number; }");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a note corresponding to a single commit from a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param sha a git ref or commit sha
     * @param {*} [options] Override http request options.
     */
    public repoGetNote (owner: string, repo: string, sha: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Note;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/notes/{sha}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'sha' + '}', encodeURIComponent(String(sha)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetNote.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetNote.');
        }

        // verify required parameter 'sha' is not null or undefined
        if (sha === null || sha === undefined) {
            throw new Error('Required parameter sha was null or undefined when calling repoGetNote.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Note;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Note");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request to get
     * @param {*} [options] Override http request options.
     */
    public repoGetPullRequest (owner: string, repo: string, index: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullRequest;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetPullRequest.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetPullRequest.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoGetPullRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get commits for a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request to get
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoGetPullRequestCommits (owner: string, repo: string, index: number, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Commit>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/commits'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetPullRequestCommits.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetPullRequestCommits.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoGetPullRequestCommits.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Commit>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Commit>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a specific review for a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request
     * @param id id of the review
     * @param {*} [options] Override http request options.
     */
    public repoGetPullReview (owner: string, repo: string, index: number, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullReview;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetPullReview.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetPullReview.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoGetPullReview.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoGetPullReview.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullReview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullReview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a specific review for a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request
     * @param id id of the review
     * @param {*} [options] Override http request options.
     */
    public repoGetPullReviewComments (owner: string, repo: string, index: number, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PullReviewComment>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetPullReviewComments.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetPullReviewComments.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoGetPullReviewComments.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoGetPullReviewComments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PullReviewComment>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PullReviewComment>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a file from a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param filepath filepath of the file to get
     * @param ref The name of the commit/branch/tag. Default the repositorys default branch (usually master)
     * @param {*} [options] Override http request options.
     */
    public repoGetRawFile (owner: string, repo: string, filepath: string, ref?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/raw/{filepath}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'filepath' + '}', encodeURIComponent(String(filepath)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetRawFile.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetRawFile.');
        }

        // verify required parameter 'filepath' is not null or undefined
        if (filepath === null || filepath === undefined) {
            throw new Error('Required parameter filepath was null or undefined when calling repoGetRawFile.');
        }

        if (ref !== undefined) {
            localVarQueryParameters['ref'] = ObjectSerializer.serialize(ref, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a release
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the release to get
     * @param {*} [options] Override http request options.
     */
    public repoGetRelease (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Release;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetRelease.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetRelease.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoGetRelease.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Release;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Release");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a release attachment
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the release
     * @param attachmentId id of the attachment to get
     * @param {*} [options] Override http request options.
     */
    public repoGetReleaseAttachment (owner: string, repo: string, id: number, attachmentId: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Attachment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'attachment_id' + '}', encodeURIComponent(String(attachmentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetReleaseAttachment.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetReleaseAttachment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoGetReleaseAttachment.');
        }

        // verify required parameter 'attachmentId' is not null or undefined
        if (attachmentId === null || attachmentId === undefined) {
            throw new Error('Required parameter attachmentId was null or undefined when calling repoGetReleaseAttachment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Attachment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Attachment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a release by tag name
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param tag tag name of the release to get
     * @param {*} [options] Override http request options.
     */
    public repoGetReleaseByTag (owner: string, repo: string, tag: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Release;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/tags/{tag}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'tag' + '}', encodeURIComponent(String(tag)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetReleaseByTag.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetReleaseByTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling repoGetReleaseByTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Release;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Release");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return all users that can be requested to review in this repo
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public repoGetReviewers (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/reviewers'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetReviewers.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetReviewers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a single commit from a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param sha a git ref or commit sha
     * @param {*} [options] Override http request options.
     */
    public repoGetSingleCommit (owner: string, repo: string, sha: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Commit;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/commits/{sha}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'sha' + '}', encodeURIComponent(String(sha)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetSingleCommit.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetSingleCommit.');
        }

        // verify required parameter 'sha' is not null or undefined
        if (sha === null || sha === undefined) {
            throw new Error('Required parameter sha was null or undefined when calling repoGetSingleCommit.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Commit;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Commit");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the tag of a repository by tag name
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param tag name of tag
     * @param {*} [options] Override http request options.
     */
    public repoGetTag (owner: string, repo: string, tag: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Tag;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/tags/{tag}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'tag' + '}', encodeURIComponent(String(tag)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetTag.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling repoGetTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Tag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Tag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a wiki page
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param pageName name of the page
     * @param {*} [options] Override http request options.
     */
    public repoGetWikiPage (owner: string, repo: string, pageName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WikiPage;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/wiki/page/{pageName}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'pageName' + '}', encodeURIComponent(String(pageName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetWikiPage.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetWikiPage.');
        }

        // verify required parameter 'pageName' is not null or undefined
        if (pageName === null || pageName === undefined) {
            throw new Error('Required parameter pageName was null or undefined when calling repoGetWikiPage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WikiPage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WikiPage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get revisions of a wiki page
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param pageName name of the page
     * @param page page number of results to return (1-based)
     * @param {*} [options] Override http request options.
     */
    public repoGetWikiPageRevisions (owner: string, repo: string, pageName: string, page?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WikiCommitList;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/wiki/revisions/{pageName}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'pageName' + '}', encodeURIComponent(String(pageName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetWikiPageRevisions.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetWikiPageRevisions.');
        }

        // verify required parameter 'pageName' is not null or undefined
        if (pageName === null || pageName === undefined) {
            throw new Error('Required parameter pageName was null or undefined when calling repoGetWikiPageRevisions.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WikiCommitList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WikiCommitList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all wiki pages
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoGetWikiPages (owner: string, repo: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<WikiPageMetaData>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/wiki/pages'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoGetWikiPages.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoGetWikiPages.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<WikiPageMetaData>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<WikiPageMetaData>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified ref or filtered repository's refs
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public repoListAllGitRefs (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Reference>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/refs'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListAllGitRefs.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListAllGitRefs.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Reference>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Reference>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List branch protections for a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public repoListBranchProtection (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<BranchProtection>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/branch_protections'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListBranchProtection.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListBranchProtection.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<BranchProtection>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<BranchProtection>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repository's branches
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListBranches (owner: string, repo: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Branch>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/branches'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListBranches.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListBranches.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Branch>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Branch>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repository's collaborators
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListCollaborators (owner: string, repo: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/collaborators'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListCollaborators.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListCollaborators.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the Git hooks in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public repoListGitHooks (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<GitHook>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/git'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListGitHooks.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListGitHooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<GitHook>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GitHook>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get specified ref or filtered repository's refs
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param ref part or full name of the ref
     * @param {*} [options] Override http request options.
     */
    public repoListGitRefs (owner: string, repo: string, ref: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Reference>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/refs/{ref}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'ref' + '}', encodeURIComponent(String(ref)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListGitRefs.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListGitRefs.');
        }

        // verify required parameter 'ref' is not null or undefined
        if (ref === null || ref === undefined) {
            throw new Error('Required parameter ref was null or undefined when calling repoListGitRefs.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Reference>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Reference>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the hooks in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListHooks (owner: string, repo: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Hook>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListHooks.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListHooks.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Hook>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Hook>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repository's keys
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param keyId the key_id to search for
     * @param fingerprint fingerprint of the key
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListKeys (owner: string, repo: string, keyId?: number, fingerprint?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<DeployKey>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/keys'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListKeys.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListKeys.');
        }

        if (keyId !== undefined) {
            localVarQueryParameters['key_id'] = ObjectSerializer.serialize(keyId, "number");
        }

        if (fingerprint !== undefined) {
            localVarQueryParameters['fingerprint'] = ObjectSerializer.serialize(fingerprint, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<DeployKey>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DeployKey>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repo's pull requests
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param state State of pull request: open or closed (optional)
     * @param sort Type of sort
     * @param milestone ID of the milestone
     * @param labels Label IDs
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListPullRequests (owner: string, repo: string, state?: 'closed' | 'open' | 'all', sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority', milestone?: number, labels?: Array<number>, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PullRequest>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListPullRequests.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListPullRequests.');
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'closed' | 'open' | 'all'");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority'");
        }

        if (milestone !== undefined) {
            localVarQueryParameters['milestone'] = ObjectSerializer.serialize(milestone, "number");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "Array<number>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PullRequest>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PullRequest>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all reviews for a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListPullReviews (owner: string, repo: string, index: number, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PullReview>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/reviews'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListPullReviews.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListPullReviews.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoListPullReviews.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PullReview>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PullReview>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List release's attachments
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the release
     * @param {*} [options] Override http request options.
     */
    public repoListReleaseAttachments (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Attachment>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}/assets'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListReleaseAttachments.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListReleaseAttachments.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoListReleaseAttachments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Attachment>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Attachment>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repo's releases
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param draft filter (exclude / include) drafts, if you dont have repo write access none will show
     * @param preRelease filter (exclude / include) pre-releases
     * @param perPage page size of results, deprecated - use limit
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListReleases (owner: string, repo: string, draft?: boolean, preRelease?: boolean, perPage?: number, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Release>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListReleases.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListReleases.');
        }

        if (draft !== undefined) {
            localVarQueryParameters['draft'] = ObjectSerializer.serialize(draft, "boolean");
        }

        if (preRelease !== undefined) {
            localVarQueryParameters['pre-release'] = ObjectSerializer.serialize(preRelease, "boolean");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Release>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Release>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repo's stargazers
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListStargazers (owner: string, repo: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/stargazers'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListStargazers.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListStargazers.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a commit's statuses
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param sha sha of the commit
     * @param sort type of sort
     * @param state type of state
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListStatuses (owner: string, repo: string, sha: string, sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex', state?: 'pending' | 'success' | 'error' | 'failure' | 'warning', page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<CommitStatus>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/statuses/{sha}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'sha' + '}', encodeURIComponent(String(sha)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListStatuses.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListStatuses.');
        }

        // verify required parameter 'sha' is not null or undefined
        if (sha === null || sha === undefined) {
            throw new Error('Required parameter sha was null or undefined when calling repoListStatuses.');
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'pending' | 'success' | 'error' | 'failure' | 'warning'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CommitStatus>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CommitStatus>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a commit's statuses, by branch/tag/commit reference
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param ref name of branch/tag/commit
     * @param sort type of sort
     * @param state type of state
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListStatusesByRef (owner: string, repo: string, ref: string, sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex', state?: 'pending' | 'success' | 'error' | 'failure' | 'warning', page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<CommitStatus>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/commits/{ref}/statuses'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'ref' + '}', encodeURIComponent(String(ref)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListStatusesByRef.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListStatusesByRef.');
        }

        // verify required parameter 'ref' is not null or undefined
        if (ref === null || ref === undefined) {
            throw new Error('Required parameter ref was null or undefined when calling repoListStatusesByRef.');
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'pending' | 'success' | 'error' | 'failure' | 'warning'");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CommitStatus>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CommitStatus>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repo's watchers
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListSubscribers (owner: string, repo: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/subscribers'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListSubscribers.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListSubscribers.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repository's tags
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param page page number of results to return (1-based)
     * @param limit page size of results, default maximum page size is 50
     * @param {*} [options] Override http request options.
     */
    public repoListTags (owner: string, repo: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Tag>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/tags'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListTags.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListTags.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Tag>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Tag>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repository's teams
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public repoListTeams (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Team>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/teams'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListTeams.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListTeams.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Team>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Team>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get list of topics that a repository has
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoListTopics (owner: string, repo: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TopicName;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/topics'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoListTopics.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoListTopics.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TopicName;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TopicName");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Merge a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request to merge
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoMergePullRequest (owner: string, repo: string, index: number, body?: MergePullRequestOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/merge'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoMergePullRequest.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoMergePullRequest.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoMergePullRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MergePullRequestOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Migrate a remote git repository
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoMigrate (body?: MigrateRepoOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/repos/migrate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MigrateRepoOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sync a mirrored repository
     * @param owner owner of the repo to sync
     * @param repo name of the repo to sync
     * @param {*} [options] Override http request options.
     */
    public repoMirrorSync (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/mirror-sync'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoMirrorSync.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoMirrorSync.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Check if a pull request has been merged
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request
     * @param {*} [options] Override http request options.
     */
    public repoPullRequestIsMerged (owner: string, repo: string, index: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/merge'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoPullRequestIsMerged.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoPullRequestIsMerged.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoPullRequestIsMerged.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search for repositories
     * @param q keyword
     * @param topic Limit search to repositories with keyword as topic
     * @param includeDesc include search of keyword within repository description (defaults to false)
     * @param uid search only for repos that the user with the given id owns or contributes to
     * @param priorityOwnerId repo owner to prioritize in the results
     * @param teamId search only for repos that belong to the given team id
     * @param starredBy search only for repos that the user with the given id has starred
     * @param _private include private repositories this user has access to (defaults to true)
     * @param isPrivate show only pubic, private or all repositories (defaults to all)
     * @param template include template repositories this user has access to (defaults to true)
     * @param archived show only archived, non-archived or all repositories (defaults to all)
     * @param mode type of repository to search for. Supported values are \&quot;fork\&quot;, \&quot;source\&quot;, \&quot;mirror\&quot; and \&quot;collaborative\&quot;
     * @param exclusive if &#x60;uid&#x60; is given, search only for repos that the user owns
     * @param repo name of the repo. Multiple repo&#39;s are ORed.
     * @param owner owner of the repo. Multiple owner&#39;s are ORed.
     * @param lang If the repo is a resource of the given language(s), the repo will be in the results. Multiple lang&#39;s are ORed.
     * @param subject resource subject. Multiple subject&#39;s are ORed.
     * @param book book (project id) that exist in a resource. If the resource contains the the book, its repository will be included in the results. Multiple book&#39;s are ORed.
     * @param includeMetadata if false, q value will only be searched for in the repo name, owner, description and title and subject; otherwise search all values of the manifest file. (defaults to false)
     * @param sort sort repos by attribute. Supported values are \&quot;alpha\&quot;, \&quot;created\&quot;, \&quot;updated\&quot;, \&quot;size\&quot;, and \&quot;id\&quot;. Default is \&quot;alpha\&quot;
     * @param order sort order, either \&quot;asc\&quot; (ascending) or \&quot;desc\&quot; (descending). Default is \&quot;asc\&quot;, ignored if \&quot;sort\&quot; is not specified.
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoSearch (q?: string, topic?: boolean, includeDesc?: boolean, uid?: number, priorityOwnerId?: number, teamId?: number, starredBy?: number, _private?: boolean, isPrivate?: boolean, template?: boolean, archived?: boolean, mode?: string, exclusive?: boolean, repo?: string, owner?: string, lang?: string, subject?: string, book?: string, includeMetadata?: boolean, sort?: string, order?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SearchResults;  }> {
        const localVarPath = this.basePath + '/repos/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (topic !== undefined) {
            localVarQueryParameters['topic'] = ObjectSerializer.serialize(topic, "boolean");
        }

        if (includeDesc !== undefined) {
            localVarQueryParameters['includeDesc'] = ObjectSerializer.serialize(includeDesc, "boolean");
        }

        if (uid !== undefined) {
            localVarQueryParameters['uid'] = ObjectSerializer.serialize(uid, "number");
        }

        if (priorityOwnerId !== undefined) {
            localVarQueryParameters['priority_owner_id'] = ObjectSerializer.serialize(priorityOwnerId, "number");
        }

        if (teamId !== undefined) {
            localVarQueryParameters['team_id'] = ObjectSerializer.serialize(teamId, "number");
        }

        if (starredBy !== undefined) {
            localVarQueryParameters['starredBy'] = ObjectSerializer.serialize(starredBy, "number");
        }

        if (_private !== undefined) {
            localVarQueryParameters['private'] = ObjectSerializer.serialize(_private, "boolean");
        }

        if (isPrivate !== undefined) {
            localVarQueryParameters['is_private'] = ObjectSerializer.serialize(isPrivate, "boolean");
        }

        if (template !== undefined) {
            localVarQueryParameters['template'] = ObjectSerializer.serialize(template, "boolean");
        }

        if (archived !== undefined) {
            localVarQueryParameters['archived'] = ObjectSerializer.serialize(archived, "boolean");
        }

        if (mode !== undefined) {
            localVarQueryParameters['mode'] = ObjectSerializer.serialize(mode, "string");
        }

        if (exclusive !== undefined) {
            localVarQueryParameters['exclusive'] = ObjectSerializer.serialize(exclusive, "boolean");
        }

        if (repo !== undefined) {
            localVarQueryParameters['repo'] = ObjectSerializer.serialize(repo, "string");
        }

        if (owner !== undefined) {
            localVarQueryParameters['owner'] = ObjectSerializer.serialize(owner, "string");
        }

        if (lang !== undefined) {
            localVarQueryParameters['lang'] = ObjectSerializer.serialize(lang, "string");
        }

        if (subject !== undefined) {
            localVarQueryParameters['subject'] = ObjectSerializer.serialize(subject, "string");
        }

        if (book !== undefined) {
            localVarQueryParameters['book'] = ObjectSerializer.serialize(book, "string");
        }

        if (includeMetadata !== undefined) {
            localVarQueryParameters['includeMetadata'] = ObjectSerializer.serialize(includeMetadata, "boolean");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SearchResults;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchResults");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get signing-key.gpg for given repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public repoSigningKey (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/signing-key.gpg'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoSigningKey.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoSigningKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Submit a pending review to an pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request
     * @param id id of the review
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoSubmitPullReview (owner: string, repo: string, index: number, id: number, body: SubmitPullReviewOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullReview;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoSubmitPullReview.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoSubmitPullReview.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoSubmitPullReview.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoSubmitPullReview.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repoSubmitPullReview.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SubmitPullReviewOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullReview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullReview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Test a push webhook
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param id id of the hook to test
     * @param {*} [options] Override http request options.
     */
    public repoTestHook (owner: string, repo: string, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/{id}/tests'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoTestHook.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoTestHook.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoTestHook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a repo's tracked times
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param user optional filter by user (available for issue managers)
     * @param since Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param before Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public repoTrackedTimes (owner: string, repo: string, user?: string, since?: Date, before?: Date, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TrackedTime>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/times'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoTrackedTimes.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoTrackedTimes.');
        }

        if (user !== undefined) {
            localVarQueryParameters['user'] = ObjectSerializer.serialize(user, "string");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "Date");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TrackedTime>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TrackedTime>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Transfer a repo ownership
     * @param owner owner of the repo to transfer
     * @param repo name of the repo to transfer
     * @param body Transfer Options
     * @param {*} [options] Override http request options.
     */
    public repoTransfer (owner: string, repo: string, body: TransferRepoOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/transfer'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoTransfer.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoTransfer.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repoTransfer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TransferRepoOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Cancel to dismiss a review for a pull request
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request
     * @param id id of the review
     * @param {*} [options] Override http request options.
     */
    public repoUnDismissPullReview (owner: string, repo: string, index: number, id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullReview;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoUnDismissPullReview.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoUnDismissPullReview.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoUnDismissPullReview.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling repoUnDismissPullReview.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullReview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullReview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a file in a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param filepath path of the file to update
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoUpdateFile (owner: string, repo: string, filepath: string, body: UpdateFileOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FileResponse;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/contents/{filepath}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'filepath' + '}', encodeURIComponent(String(filepath)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoUpdateFile.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoUpdateFile.');
        }

        // verify required parameter 'filepath' is not null or undefined
        if (filepath === null || filepath === undefined) {
            throw new Error('Required parameter filepath was null or undefined when calling repoUpdateFile.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling repoUpdateFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdateFileOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FileResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FileResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Merge PR's baseBranch into headBranch
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param index index of the pull request to get
     * @param style how to update pull request
     * @param {*} [options] Override http request options.
     */
    public repoUpdatePullRequest (owner: string, repo: string, index: number, style?: 'merge' | 'rebase', options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{index}/update'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoUpdatePullRequest.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoUpdatePullRequest.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling repoUpdatePullRequest.');
        }

        if (style !== undefined) {
            localVarQueryParameters['style'] = ObjectSerializer.serialize(style, "'merge' | 'rebase'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace list of topics for a repository
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public repoUpdateTopics (owner: string, repo: string, body?: RepoTopicOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/topics'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling repoUpdateTopics.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling repoUpdateTopics.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RepoTopicOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary search topics via keyword
     * @param q keywords to search
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public topicSearch (q: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TopicResponse>;  }> {
        const localVarPath = this.basePath + '/topics/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling topicSearch.');
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TopicResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TopicResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Check if the current user is watching a repo
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public userCurrentCheckSubscription (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WatchInfo;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/subscription'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userCurrentCheckSubscription.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userCurrentCheckSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WatchInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WatchInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unwatch a repo
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public userCurrentDeleteSubscription (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/subscription'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userCurrentDeleteSubscription.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userCurrentDeleteSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Watch a repo
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public userCurrentPutSubscription (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WatchInfo;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/subscription'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userCurrentPutSubscription.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userCurrentPutSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WatchInfo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WatchInfo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List a user's tracked times in a repo
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param user username of user
     * @param {*} [options] Override http request options.
     */
    public userTrackedTimes (owner: string, repo: string, user: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TrackedTime>;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/times/{user}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userTrackedTimes.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userTrackedTimes.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling userTrackedTimes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TrackedTime>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TrackedTime>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SettingsApiApiKeys {
    AccessToken,
    AuthorizationHeaderToken,
    SudoHeader,
    SudoParam,
    TOTPHeader,
    Token,
}

export class SettingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AccessToken': new ApiKeyAuth('query', 'access_token'),
        'AuthorizationHeaderToken': new ApiKeyAuth('header', 'Authorization'),
        'BasicAuth': new HttpBasicAuth(),
        'SudoHeader': new ApiKeyAuth('header', 'Sudo'),
        'SudoParam': new ApiKeyAuth('query', 'sudo'),
        'TOTPHeader': new ApiKeyAuth('header', 'X-GITEA-OTP'),
        'Token': new ApiKeyAuth('query', 'token'),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SettingsApiApiKeys, value: string) {
        (this.authentications as any)[SettingsApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.BasicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * 
     * @summary Get instance's global settings for api
     * @param {*} [options] Override http request options.
     */
    public getGeneralAPISettings (options: any = {}) : Promise<{ response: http.IncomingMessage; body: GeneralAPISettings;  }> {
        const localVarPath = this.basePath + '/settings/api';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GeneralAPISettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GeneralAPISettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get instance's global settings for Attachment
     * @param {*} [options] Override http request options.
     */
    public getGeneralAttachmentSettings (options: any = {}) : Promise<{ response: http.IncomingMessage; body: GeneralAttachmentSettings;  }> {
        const localVarPath = this.basePath + '/settings/attachment';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GeneralAttachmentSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GeneralAttachmentSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get instance's global settings for repositories
     * @param {*} [options] Override http request options.
     */
    public getGeneralRepositorySettings (options: any = {}) : Promise<{ response: http.IncomingMessage; body: GeneralRepoSettings;  }> {
        const localVarPath = this.basePath + '/settings/repository';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GeneralRepoSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GeneralRepoSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get instance's global settings for ui
     * @param {*} [options] Override http request options.
     */
    public getGeneralUISettings (options: any = {}) : Promise<{ response: http.IncomingMessage; body: GeneralUISettings;  }> {
        const localVarPath = this.basePath + '/settings/ui';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GeneralUISettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GeneralUISettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserApiApiKeys {
    AccessToken,
    AuthorizationHeaderToken,
    SudoHeader,
    SudoParam,
    TOTPHeader,
    Token,
}

export class UserApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AccessToken': new ApiKeyAuth('query', 'access_token'),
        'AuthorizationHeaderToken': new ApiKeyAuth('header', 'Authorization'),
        'BasicAuth': new HttpBasicAuth(),
        'SudoHeader': new ApiKeyAuth('header', 'Sudo'),
        'SudoParam': new ApiKeyAuth('query', 'sudo'),
        'TOTPHeader': new ApiKeyAuth('header', 'X-GITEA-OTP'),
        'Token': new ApiKeyAuth('query', 'token'),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserApiApiKeys, value: string) {
        (this.authentications as any)[UserApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.BasicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.BasicAuth.password = password;
    }
    /**
     * 
     * @summary Create a repository
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public createCurrentUserRepo (body?: CreateRepoOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repository;  }> {
        const localVarPath = this.basePath + '/user/repos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateRepoOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repository;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repository");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get user settings
     * @param {*} [options] Override http request options.
     */
    public getUserSettings (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<UserSettings>;  }> {
        const localVarPath = this.basePath + '/user/settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<UserSettings>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<UserSettings>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a Token to verify
     * @param {*} [options] Override http request options.
     */
    public getVerificationToken (options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/user/gpg_key_token';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update user settings
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public updateUserSettings (body?: UserSettingsOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<UserSettings>;  }> {
        const localVarPath = this.basePath + '/user/settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserSettingsOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<UserSettings>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<UserSettings>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add email addresses
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userAddEmail (body?: CreateEmailOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Email>;  }> {
        const localVarPath = this.basePath + '/user/emails';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateEmailOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Email>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Email>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Check if one user is following another user
     * @param follower username of following user
     * @param followee username of followed user
     * @param {*} [options] Override http request options.
     */
    public userCheckFollowing (follower: string, followee: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{follower}/following/{followee}'
            .replace('{' + 'follower' + '}', encodeURIComponent(String(follower)))
            .replace('{' + 'followee' + '}', encodeURIComponent(String(followee)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'follower' is not null or undefined
        if (follower === null || follower === undefined) {
            throw new Error('Required parameter follower was null or undefined when calling userCheckFollowing.');
        }

        // verify required parameter 'followee' is not null or undefined
        if (followee === null || followee === undefined) {
            throw new Error('Required parameter followee was null or undefined when calling userCheckFollowing.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary creates a new OAuth2 application
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userCreateOAuth2Application (body: CreateOAuth2ApplicationOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OAuth2Application;  }> {
        const localVarPath = this.basePath + '/user/applications/oauth2';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userCreateOAuth2Application.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateOAuth2ApplicationOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OAuth2Application;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OAuth2Application");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create an access token
     * @param username username of user
     * @param userCreateToken 
     * @param {*} [options] Override http request options.
     */
    public userCreateToken (username: string, userCreateToken?: CreateAccessTokenOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AccessToken;  }> {
        const localVarPath = this.basePath + '/users/{username}/tokens'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userCreateToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(userCreateToken, "CreateAccessTokenOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AccessToken;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AccessToken");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Check whether a user is followed by the authenticated user
     * @param username username of followed user
     * @param {*} [options] Override http request options.
     */
    public userCurrentCheckFollowing (username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/following/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userCurrentCheckFollowing.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Whether the authenticated is starring the repo
     * @param owner owner of the repo
     * @param repo name of the repo
     * @param {*} [options] Override http request options.
     */
    public userCurrentCheckStarring (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/starred/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userCurrentCheckStarring.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userCurrentCheckStarring.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unfollow a user
     * @param username username of user to unfollow
     * @param {*} [options] Override http request options.
     */
    public userCurrentDeleteFollow (username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/following/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userCurrentDeleteFollow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a GPG key
     * @param id id of key to delete
     * @param {*} [options] Override http request options.
     */
    public userCurrentDeleteGPGKey (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/gpg_keys/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling userCurrentDeleteGPGKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a public key
     * @param id id of key to delete
     * @param {*} [options] Override http request options.
     */
    public userCurrentDeleteKey (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/keys/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling userCurrentDeleteKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unstar the given repo
     * @param owner owner of the repo to unstar
     * @param repo name of the repo to unstar
     * @param {*} [options] Override http request options.
     */
    public userCurrentDeleteStar (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/starred/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userCurrentDeleteStar.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userCurrentDeleteStar.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a GPG key
     * @param id id of key to get
     * @param {*} [options] Override http request options.
     */
    public userCurrentGetGPGKey (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GPGKey;  }> {
        const localVarPath = this.basePath + '/user/gpg_keys/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling userCurrentGetGPGKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GPGKey;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GPGKey");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a public key
     * @param id id of key to get
     * @param {*} [options] Override http request options.
     */
    public userCurrentGetKey (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PublicKey;  }> {
        const localVarPath = this.basePath + '/user/keys/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling userCurrentGetKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PublicKey;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PublicKey");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the authenticated user's followers
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userCurrentListFollowers (page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/user/followers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the users that the authenticated user is following
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userCurrentListFollowing (page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/user/following';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the authenticated user's GPG keys
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userCurrentListGPGKeys (page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<GPGKey>;  }> {
        const localVarPath = this.basePath + '/user/gpg_keys';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<GPGKey>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GPGKey>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the authenticated user's public keys
     * @param fingerprint fingerprint of the key
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userCurrentListKeys (fingerprint?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PublicKey>;  }> {
        const localVarPath = this.basePath + '/user/keys';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (fingerprint !== undefined) {
            localVarQueryParameters['fingerprint'] = ObjectSerializer.serialize(fingerprint, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PublicKey>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PublicKey>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the repos that the authenticated user owns
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userCurrentListRepos (page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }> {
        const localVarPath = this.basePath + '/user/repos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Repository>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary The repos that the authenticated user has starred
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userCurrentListStarred (page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }> {
        const localVarPath = this.basePath + '/user/starred';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Repository>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List repositories watched by the authenticated user
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userCurrentListSubscriptions (page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }> {
        const localVarPath = this.basePath + '/user/subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Repository>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a GPG key
     * @param form 
     * @param {*} [options] Override http request options.
     */
    public userCurrentPostGPGKey (form?: CreateGPGKeyOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GPGKey;  }> {
        const localVarPath = this.basePath + '/user/gpg_keys';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(form, "CreateGPGKeyOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GPGKey;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GPGKey");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a public key
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userCurrentPostKey (body?: CreateKeyOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PublicKey;  }> {
        const localVarPath = this.basePath + '/user/keys';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateKeyOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PublicKey;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PublicKey");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Follow a user
     * @param username username of user to follow
     * @param {*} [options] Override http request options.
     */
    public userCurrentPutFollow (username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/following/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userCurrentPutFollow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Star the given repo
     * @param owner owner of the repo to star
     * @param repo name of the repo to star
     * @param {*} [options] Override http request options.
     */
    public userCurrentPutStar (owner: string, repo: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/starred/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userCurrentPutStar.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userCurrentPutStar.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the current user's tracked times
     * @param since Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param before Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {*} [options] Override http request options.
     */
    public userCurrentTrackedTimes (since?: Date, before?: Date, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TrackedTime>;  }> {
        const localVarPath = this.basePath + '/user/times';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "Date");
        }

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TrackedTime>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TrackedTime>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary delete an access token
     * @param username username of user
     * @param token token to be deleted, identified by ID and if not available by name
     * @param {*} [options] Override http request options.
     */
    public userDeleteAccessToken (username: string, token: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/tokens/{token}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'token' + '}', encodeURIComponent(String(token)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userDeleteAccessToken.');
        }

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling userDeleteAccessToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete email addresses
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userDeleteEmail (body?: DeleteEmailOption, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/emails';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DeleteEmailOption")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary delete an OAuth2 Application
     * @param id token to be deleted
     * @param {*} [options] Override http request options.
     */
    public userDeleteOAuth2Application (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/applications/oauth2/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling userDeleteOAuth2Application.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a user
     * @param username username of user to get
     * @param {*} [options] Override http request options.
     */
    public userGet (username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: User;  }> {
        const localVarPath = this.basePath + '/users/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userGet.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the authenticated user
     * @param {*} [options] Override http request options.
     */
    public userGetCurrent (options: any = {}) : Promise<{ response: http.IncomingMessage; body: User;  }> {
        const localVarPath = this.basePath + '/user';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get a user's heatmap
     * @param username username of user to get
     * @param {*} [options] Override http request options.
     */
    public userGetHeatmapData (username: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<UserHeatmapData>;  }> {
        const localVarPath = this.basePath + '/users/{username}/heatmap'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userGetHeatmapData.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<UserHeatmapData>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<UserHeatmapData>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary get an OAuth2 Application
     * @param id Application ID to be found
     * @param {*} [options] Override http request options.
     */
    public userGetOAuth2Application (id: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OAuth2Application;  }> {
        const localVarPath = this.basePath + '/user/applications/oauth2/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling userGetOAuth2Application.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OAuth2Application;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OAuth2Application");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the authenticated user's oauth2 applications
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userGetOauth2Application (page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<OAuth2Application>;  }> {
        const localVarPath = this.basePath + '/user/applications/oauth2';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<OAuth2Application>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<OAuth2Application>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get list of all existing stopwatches
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userGetStopWatches (page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<StopWatch>;  }> {
        const localVarPath = this.basePath + '/user/stopwatches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<StopWatch>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<StopWatch>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the authenticated user's access tokens
     * @param username username of user
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userGetTokens (username: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<AccessToken>;  }> {
        const localVarPath = this.basePath + '/users/{username}/tokens'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userGetTokens.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<AccessToken>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AccessToken>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the authenticated user's email addresses
     * @param {*} [options] Override http request options.
     */
    public userListEmails (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Email>;  }> {
        const localVarPath = this.basePath + '/user/emails';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Email>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Email>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the given user's followers
     * @param username username of user
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userListFollowers (username: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/users/{username}/followers'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userListFollowers.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the users that the given user is following
     * @param username username of user
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userListFollowing (username: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/users/{username}/following'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userListFollowing.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the given user's GPG keys
     * @param username username of user
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userListGPGKeys (username: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<GPGKey>;  }> {
        const localVarPath = this.basePath + '/users/{username}/gpg_keys'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userListGPGKeys.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<GPGKey>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GPGKey>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the given user's public keys
     * @param username username of user
     * @param fingerprint fingerprint of the key
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userListKeys (username: string, fingerprint?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<PublicKey>;  }> {
        const localVarPath = this.basePath + '/users/{username}/keys'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userListKeys.');
        }

        if (fingerprint !== undefined) {
            localVarQueryParameters['fingerprint'] = ObjectSerializer.serialize(fingerprint, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<PublicKey>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<PublicKey>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the repos owned by the given user
     * @param username username of user
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userListRepos (username: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }> {
        const localVarPath = this.basePath + '/users/{username}/repos'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userListRepos.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Repository>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary The repos that the given user has starred
     * @param username username of user
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userListStarred (username: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }> {
        const localVarPath = this.basePath + '/users/{username}/starred'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userListStarred.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Repository>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List the repositories watched by a user
     * @param username username of the user
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userListSubscriptions (username: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }> {
        const localVarPath = this.basePath + '/users/{username}/subscriptions'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userListSubscriptions.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Repository>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Repository>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List all the teams a user belongs to
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userListTeams (page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<Team>;  }> {
        const localVarPath = this.basePath + '/user/teams';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<Team>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Team>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Search for users
     * @param q keyword
     * @param uid ID of the user to search for
     * @param lang If the user has one or more repos with the given language(s), the org will be in the results. Multiple lang&#39;s are ORed.
     * @param page page number of results to return (1-based)
     * @param limit page size of results
     * @param {*} [options] Override http request options.
     */
    public userSearch (q?: string, uid?: number, lang?: string, page?: number, limit?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/users/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (uid !== undefined) {
            localVarQueryParameters['uid'] = ObjectSerializer.serialize(uid, "number");
        }

        if (lang !== undefined) {
            localVarQueryParameters['lang'] = ObjectSerializer.serialize(lang, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary update an OAuth2 Application, this includes regenerating the client secret
     * @param id application to be updated
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userUpdateOAuth2Application (id: number, body: CreateOAuth2ApplicationOptions, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OAuth2Application;  }> {
        const localVarPath = this.basePath + '/user/applications/oauth2/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling userUpdateOAuth2Application.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userUpdateOAuth2Application.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateOAuth2ApplicationOptions")
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OAuth2Application;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OAuth2Application");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Verify a GPG key
     * @param {*} [options] Override http request options.
     */
    public userVerifyGPGKey (options: any = {}) : Promise<{ response: http.IncomingMessage; body: GPGKey;  }> {
        const localVarPath = this.basePath + '/user/gpg_key_verify';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.AccessToken.applyToRequest(localVarRequestOptions);

        this.authentications.AuthorizationHeaderToken.applyToRequest(localVarRequestOptions);

        this.authentications.BasicAuth.applyToRequest(localVarRequestOptions);

        this.authentications.SudoHeader.applyToRequest(localVarRequestOptions);

        this.authentications.SudoParam.applyToRequest(localVarRequestOptions);

        this.authentications.TOTPHeader.applyToRequest(localVarRequestOptions);

        this.authentications.Token.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GPGKey;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GPGKey");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
